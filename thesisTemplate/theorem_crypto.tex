\chapter{Theorem Prover and Cryptography}
\label{cha:theorem_crypto}
 
 \fix{Can I introduce Write Hilbert's idea of mathematical formalism/Frege}

A proof assistant is a computer program which assists users in development of mathematical proofs. The idea of 
developing mathematical proofs using computer goes back to Automath (automating mathematics)
[cite Automath] and LCF [cite Logic for computation] project. The 
Automath project (1967 until the early 80's)  was initiative of De Bruijn, and the aim of the project was to develop
a language for expressing mathematical theories which can be verified by aid of computer.  Automath was first 
practical project to exploit the Curry-Howard isomorphism (proofs-as-programs and formulas-as-types)
 [reference here]. DeBruijn  was likely unaware of this correspondence, and he almost re-invented it 
 ([Wiki entry on Curry-Howard]). Many researchers refers Curry-Howard isomorphism as 
 Curry-Howard-DeBruijn isomorphism. Automath project can be seen as the precursor of
 proof assistants NuPrl [cite here] and Coq [cite coq].   Some other notable  proof assistants are 
 LCF (Logic for Computable Functions)  [cite Milner?], Mizar [cite], Nqthm/ACl2 [cite], PVS [cite], 
 HOL (a family of tools derived from LCF theorem prover), Agda [cite], and Lean [cite].


In this chapter, I will give a overview of theoretical foundation of 
Coq thorem prover i.e. Calculus of Construction and  
Calculus of Inductive Construction, followed by Dependent type 
and how it leads to 
correct by construction (paradigm?) with a example of dependent 
typed lambda calculus. I will also discuss distinction between Type and Prop 
and how it affects the code extraction, a feature for extracting 
certified functional programs from specification proofs, and the 
specification language Gallina. Finally, I would 
argue that why should we trust the Coq proofs even though it does not 
match or look like a mathematical proof.




\section{Coq: Interactive Theorem prover}
\label{sec:problemstatement}
\fix{explain here a about Coq. What is Coq ?}
The Coq proof assistant  is an interactive theorem prover based on
underlying theory of Calculus of 
Inductive Construction [Cite Pualine Mohring]  which itself is an 
augmentation of Calculus of Construction 
[cite Huet and Coquand] with inductive data-type.  
 

\subsection{Calculus of Construction}
\subsection{Calculus of Inductive Construction}
\fix{Flesh out the details of 
 Calculus of construction and Inductive construction}
 \fix{Write here about syntax and semantics of CIC}
 
 

 
\subsection{Dependent Types}
    Type system is a wide spectrum ranging from Scheme where 
    type is runtime concept to Haskell to Coq 
    
    \subsubsection{Example : Dependent Type Lambda Calculus}
     Lambda Calculus encoded in Coq using Inductive data type. 
     
 \subsubsection{Correct by Construction}
 \fix{Combing program with proofs leads to one stop solution, mainly 
     correct by construction}
  Well typed program can't go wrong. 
  Give a example of dependent type lambda calculus(Dirk's white board)
  Hello World is dependent type Vector 
 \subsubsection{Type vs. Prop : Code Extraction}
 \fix{explain here the difference between Prop and Types. How it affects 
  the code extraction }
  It's good starting point to tell the reader that we have two definitions, 
  one in type and other in prop. Why ? Because Type computes, but it's
  not very intuitive for human inspection while Prop does not compute, 
  but it's very intuitive for human inspection. We have connected that 
  the definition expressed in Type is equivalent to Prop definition. 
 
 \subsubsection{Gallina : The Specification Language}
  The example, dependent type lambda calculus, I gave in previous 
  section was encoded in Coq's specification language Gallina. 
  Gallina is a highly expressive specification 
  language for development of mathematical theories and proving the    
  theorems about these  theories; however, writing proofs in Gallina
  is very tedious and cumbersome. It's not suitable for large proof 
  development, and to ease the proof development Coq also provides 
  tactics.  The user interacting with Coq theorem prover applies these 
  tactics to build the  Gallina term  which otherwise would  
  be very laborious.
  
  \fix{Can I give a simple example to demonstrate the difference 
     between proof build directly in Gallina and proof build using 
     tactics}
  
 
  

 
 \subsection{Trusting Coq proofs}
  The fundamental question for trusting the Coq proofs is two fold: 
  i) is the logic (CIC) sound ?, ii) is the implementation correct ?. 
  The logic has already been reviewed by many peers and proved correct 
  using some meta-logic. The 
  Coq implementation itself can be partitioned into two parts: 
  i) Validity Checker (Small kernel), 
  ii) Tactic language to build the proofs.
  We lay our trust in validity checker, because it's small kernel. If there
  is bug in tactic language which often is the case then build proof would 
  not pass the validity checker.  
  
  Try to write here how Fuzzer failed to find bugs in Compcert. 
  
\section{Summary} 
  Paves the path to Cryptography. 
    
\section{Cryptography}
    Write some basic crypto stuff
    
    \subsection{Homomorphic Encryption}
     Add the details of 
     homomorphic encryption 
     \subsubsection{El-Gamal Encryption Scheme}
        Give both additive and multiplicative
     \subsubsection{Pallier Encryption Scheme}
        Write some description
     \subsection{Commitment Schemes}   
        \subsubsection{Hash Based Commitment Scheme}
        \subsubsection{Discrete Logarithm Based Commitment Scheme}
         Pedersen's Commitment Scheme
     \subsection{Zero Knowledge Proof}
  		Details from 
  	 \subsection{Sigma Protocol : Efficient Zero Knowledge Proof}
  



\section{Summary}










%
%%\label{sec:problemstatement}
%Now I give a small example which defines natural number, addition of two natural numbers, and 
%proof that addition over natural number is commutative.   We can define 
%natural number in Coq using inductive data type (listing 1.1), addition of the natural numbers 
%(listing 1.2), and proof that addition of natural numbers is commutative written in Gallina (listing 1.3).
%
%\begin{lstlisting}[language=haskell, numbers=none, basicstyle=\ttfamily, 
%caption=Inductive Data Type for Natural Numbers,  captionpos=b, xleftmargin=.1\textwidth]
%
%Inductive Natural : Type :=
% | O : Natural
% | Succ : Natural -> Natural
%
%\end{lstlisting}
%
%More precisely, the interpretation is that Natural is a inductive type with two constructors: i) O representing zero,
%and ii) Succ representing successor which takes a Natural number and gives next Natural number.
%
%\fix{Change the Addition into infix symbol + and use + in proofs. It will convey the idea more clearly}
%\begin{lstlisting}[language=haskell, numbers=none, basicstyle=\ttfamily,  caption=Addition function for Natural Numbers,  captionpos=b, xleftmargin=.1\textwidth]
%
% 
%Fixpoint Addition (n m : Natural) : Natural :=
%  match n with
%  | O => m
%  | Succ n' => Succ (Addition n' m)
%  end.
%
%(* Notation for Addition. Now we can use + instead of 
%   writing Addition *)
%Notation "x + y" := (Addition x y)
%            (at level 50, left associativity).
%\end{lstlisting}
%
%We define the addition by pattern matching on first argument \textbf{n}. When \textbf{n} is 
%O (zero), then we sum is \textbf{m}, and if \textbf{n} is \textbf{Succ n'}, then sum is successor of 
%\textbf{n' +  m}.
%
%\begin{lstlisting}[language=haskell, numbers=none, basicstyle=\ttfamily,  caption=Addition function for Natural Numbers,  captionpos=b, xleftmargin=.1\textwidth]
%
%Theorem Addition_by_zero : forall (n : Natural), n + O = n.
%  refine (fix IHa (n : Natural) : n + O = n :=
%            match n as nz return (nz + O = nz) with
%            | O => eq_refl
%            | Succ n' =>
%              let IHn' := IHa n' in
%              eq_ind_r (fun m => Succ m = Succ n') eq_refl IHn'
%            end).
%Qed.
%
%  
%Lemma Successor_addition : forall (n m : Natural),
%    Succ (n + m) = n + (Succ m).
%  refine
%    (fix IHn (n : Natural) : forall m : Natural,
%        Succ (n + m) = n + (Succ m) :=
%       match n as nz return (forall m : Natural,
%                                Succ (nz + m) =
%                                nz + (Succ m)) with
%       | O => fun m : Natural => eq_refl
%       | Succ n' =>
%         fun m : Natural =>
%           eq_ind (Succ (n' + m))
%                  (fun t => Succ (Succ (n' + m)) = Succ t)
%                  eq_refl (n' + (Succ m)) (IHn n' m)
%       end).
%Qed.
%     
%
%    
%Theorem Addition_is_commutative :
%  forall (n m : Natural), n +  m = m + n.
%  refine
%    (fix IHn (n : Natural) : forall m : Natural,
%        n + m = m + n :=
%       match n as nz return (forall m : Natural,
%                                nz + m =
%                                m + nz) with
%       | O => fun m : Natural => eq_ind_r (fun t => m = t)
%                                      eq_refl
%                                      (Addition_by_zero m)
%       | Succ n' =>
%         fun m  =>
%           eq_ind (Succ (m + n'))
%                  (fun t => Succ (n' + m) = t)
%                  (eq_ind_r (fun t => Succ t = Succ (m + n'))
%                            eq_refl (IHn n' m))
%                  (m + (Succ n'))
%                  (Successor_addition m n')
%       end).
%Qed.
%
%
%\end{lstlisting}
%
%
%We need two additional Lemma:
% i) $Addition\_by\_zero$, a proof of n + 0 = 0,
% and ii) $Successor\_addition$, a proof of Succ (n + m) = n + (Succ m) 
% to prove that addition on Natural is commutative ($Addition\_is\_commutative$), 
% 
% One thing that can't escape from the reader's eyes is that the proofs written in Gallina is verbose, and they don't 
% appear anywhere compared to a proof that would have been written by a mathematician. Well, we can lift the burden 
% of verbosity by using tactics provided by Coq; however, there is no universally accepted solution in Coq community 
% for second problem. There has been some research in declarative style proof writing 
% \footnote{www-verimag.imag.fr/~corbinea/ftp/publis/bricks-poster.pdf}, but it is not widely practised in Coq 
% community. The proof of addition on Natural is commutative re-written using tactics (Listing 1.4)
% 
% 
% \begin{lstlisting}[language=haskell, numbers=none, basicstyle=\ttfamily,  caption=Addition function for Natural Numbers,  captionpos=b, xleftmargin=.1\textwidth]
%
%Lemma Addition_by_zero : forall (n : Natural), n + O = n.
%  induction n; cbn; [auto | rewrite IHn; auto].
%Qed.
%
%
%Lemma Successor_addition : forall (n m : Natural),
%    Succ (n + m) = n + (Succ m).
%Proof.
%  induction n; intros m;
%    cbn; [auto | rewrite <- IHn; auto].
%Qed.
%
%
%Theorem Addition_is_commutative :
%  forall (n m : Natural), n +  m = m + n.
%Proof.
%  induction n; intro m;
%    [rewrite Addition_by_zero |
%     rewrite <- Successor_addition;
%     rewrite <- IHn]; auto.
%Qed.
%
%\end{lstlisting}
%
%Section~\ref{sec:motivation} xxxx.\\
%
%
%Section~\ref{sec:relatedwork} yyyy.\\
%
%
%%\section{Motivation}
%%\label{sec:motivation}
%
%
%%\section{Related work}
%%\label{sec:relatedwork}
%%You may reference other papers. For example: 
%%Generational garbage collection~\citep{LH:83,Moon:84,Ungar:84} is perhaps the
%%single most important advance in garbage collection since the first collectors
%%were developed in the early 1960s. (doi: "doi" should just be the doi part, not
%%the full URL, and it will be made to link to dx.doi.org and resolve.
%%shortname: gives an optional short name for a conference like PLDI '08.)
%%
%%
%%
%%
%%
%%\section{Summary}
%%Summary what you discussed in this chapter, and mention the story in next
%%chapter. Readers should roughly understand what your thesis takes about by only reading
%%words at the beginning and the end (Summary) of each chapter.
%
%
%
