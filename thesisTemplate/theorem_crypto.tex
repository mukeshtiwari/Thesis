\chapter{Theorem Prover and Cryptography}
\label{cha:theorem_crypto}
 

A proof assistant or theorem prover is a computer program which assists users in development 
of mathematical proofs. The idea of 
developing mathematical proofs using computer goes back to Automath (automating mathematics)
\citep{deBruijn1983} and LCF \citep{Milner:1972:IAS:942578.807067}. The 
Automath project (1967 until the early 80's)  was initiative of De Bruijn, and the aim of the project was to 
develop a language for expressing mathematical theories which can be verified by aid of computer.  
Automath was first 
practical project to exploit the Curry-Howard isomorphism (proofs-as-programs and formulas-as-types). 
DeBruijn  was likely unaware of this correspondence, and he almost re-invented it.
Automath project can be seen as the precursor of
 proof assistants NuPrl \citep{Constable:1986:IMN:10510} and Coq \citep{Bertot:2004:ITP}.  
 Some other notable  proof assistants are 
 Nqthm/ACl2 \citep{507872}, PVS \citep{Owre:1992:PPV:648230.752639},
 HOL (a family of tools derived from LCF theorem prover) \citep{Slind:2008:BOH:1459784.1459792}
 \citep{Harrison:1996:HLT:646184.682934} \citep{Nipkow:2002:IHP},
 Agda \citep{Norell:2008:DTP:1813347.1813352}, and Lean \citep{10.1007/978-3-319-21401-6_26}.


\textbf{Chapter overview:}
 This chapter is overview of Coq theorem prover and Cryptographic primitives. 
 In the section \ref{sec:problemstatement}, I will give a brief overview of 
 theoretical foundation, calculus of construction (\ref{sec:cc}) and calculus of inductive 
 construction (\ref{sec:cic}), of Coq. In the section \ref{sec:deplambda}, I will focus 
 on dependent types and  how it leads to correct by construction paradigm
 by giving a well typed interpretor for simple typed lambda calculus. 
 In the section \ref{sec:typeprop}, I will discuss about \texttt{Type} and \texttt{Prop}
 which is very crucial from program extraction point of view.  Our goal during 
 this course of formalization was not only proving the correctness of 
 Schulze method, but extracting a executable OCaml/Haskell code to count 
 ballots. Section \ref{sec:gallina} focuses on Coq specification language 
 \texttt{Gallina} with a example showing that why writing proofs using  
 \texttt{Gallina} is difficult and cumbersome, and how it can be eased by 
 using tactics. Finally, in the section  \ref{sec:coqproof}, we will take 
 philosophical route to justify that why should we trust in Coq proofs 
 even though they do not appear anywhere near to a proof written by 
 a human. 


\section{Coq: Interactive Proof Assistant}
\label{sec:problemstatement}
Coq  is an interactive proof assistant (theorem prover) based on
theory of Calculus of 
Inductive Construction \citep{Paulin-Mohring:1993:IDS:645891.671440} which itself is an 
augmentation of Calculus of Construction 
\citep{Coquand:1988:CC:47724.47725} with inductive data-type.  
 

\subsection{Calculus of Construction}
\label{sec:cc}
\subsection{Calculus of Inductive Construction}
\label{sec:cic}
\fix{Flesh out the details of 
 Calculus of construction and Inductive construction}
 \fix{Write here about syntax and semantics of CIC}
 
 

    
 \subsection{Correct by Construction: Type Safe Printf}
 \label{sec:deplambda}
  One of the highly sought feature of Coq is dependent type. 
  Dependent 
  type makes  it natural to express specifications (proofs) 
  at type level. These specifications enables larger set of 
  logical errors to eliminated at compile time. 
  
  
  \begin{verbatim}
  
  
Require Import Coq.Strings.Ascii.
Require Import Coq.Strings.String.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Strings.BinaryString.
Open Scope Z.

Inductive format :=
| Fend : format
| Fint : format -> format
| Fstring : format -> format
| Fother : ascii -> format -> format.


Fixpoint format_string (inp : string) : format :=
  match inp with
  | EmptyString => Fend
  | String ("%"%char) (String ("d"%char) rest) => Fint (format_string rest)
  | String ("%"%char) (String ("s"%char) rest) => Fstring (format_string rest)
  | String c rest => Fother c (format_string rest)
  end.

Eval compute in format_string "%d%d%s".

Fixpoint interp_format (f : format) : Type :=
  match f with
  | Fint f => Z  -> interp_format f
  | Fstring f => string -> interp_format f
  | Fother c f => interp_format f
  | Fend => string
  end.

Eval compute in interp_format (format_string "%d%s%s").

Eval compute in interp_format (format_string "A number: %d, and a string: %s").

Fixpoint value_function (f : format) (s : string) : interp_format f :=
  match f with
  | Fint f' => fun i => value_function f' (s ++ of_Z i)
  | Fstring f' => fun i => value_function f' (s ++ i)
  | Fother c f' => value_function f' (s ++ String c EmptyString)
  | Fend => s
  end.


Definition printf s := value_function (format_string s) "".

Eval compute in printf "%s %s %d" "hi"%string "there"%string 123%Z.
                                        
\end{verbatim}
  
  
  
     Lambda Calculus encoded in Coq using Inductive data type. 
 \fix{Combing program with proofs leads to one stop solution, mainly 
     correct by construction}
  Well typed program can't go wrong. 
  Give a example of dependent type lambda calculus(Dirk's white board)
  Hello World is dependent type Vector 
\subsection{Type vs. Prop: Code Extraction}
\label{sec:typeprop}
 \fix{explain here the difference between Prop and Types. How it affects 
  the code extraction }
  It's good starting point to tell the reader that we have two definitions, 
  one in type and other in prop. Why ? Because Type computes, but it's
  not very intuitive for human inspection while Prop does not compute, 
  but it's very intuitive for human inspection. We have connected that 
  the definition expressed in Type is equivalent to Prop definition. 
 
 \subsection{Gallina : The Specification Language}
 \label{sec:gallina}
  The example, dependent type lambda calculus, I gave in previous 
  section was encoded in Coq's specification language Gallina. 
  Gallina is a highly expressive specification 
  language for development of mathematical theories and proving the    
  theorems about these  theories; however, writing proofs in Gallina
  is very tedious and cumbersome. It's not suitable for large proof 
  development, and to ease the proof development Coq also provides 
  tactics.  The user interacting with Coq theorem prover applies these 
  tactics to build the  Gallina term  which otherwise would  
  be very laborious.
  
  \fix{Can I give a simple example to demonstrate the difference 
     between proof build directly in Gallina and proof build using 
     tactics}
  
 

 \subsection{Trusting Coq proofs}
 \label{sec:coqproof}
  The fundamental question for trusting the Coq proofs is two fold: 
  i) is the logic (CIC) sound ?, ii) is the implementation correct ?. 
  The logic has already been reviewed by many peers and proved correct 
  using some meta-logic. The 
  Coq implementation itself can be partitioned into two parts: 
  i) Validity Checker (Small kernel), 
  ii) Tactic language to build the proofs.
  We lay our trust in validity checker, because it's small kernel. If there
  is bug in tactic language which often is the case then build proof would 
  not pass the validity checker.  
  
  Try to write here how Fuzzer failed to find bugs in Compcert. 
  
\section{Summary} 
  Paves the path to Cryptography. 
    
\section{Cryptography}
    Write some basic crypto stuff
    
    \subsection{Homomorphic Encryption}
     Add the details of 
     homomorphic encryption 
     \subsubsection{El-Gamal Encryption Scheme}
        Give both additive and multiplicative
     \subsubsection{Pallier Encryption Scheme}
        Write some description
     \subsection{Commitment Schemes}   
        \subsubsection{Hash Based Commitment Scheme}
        \subsubsection{Discrete Logarithm Based Commitment Scheme}
         Pedersen's Commitment Scheme
     \subsection{Zero Knowledge Proof}
  		Details from 
  	 \subsection{Sigma Protocol : Efficient Zero Knowledge Proof}
  



\section{Summary}










%
%%\label{sec:problemstatement}
%Now I give a small example which defines natural number, addition of two natural numbers, and 
%proof that addition over natural number is commutative.   We can define 
%natural number in Coq using inductive data type (listing 1.1), addition of the natural numbers 
%(listing 1.2), and proof that addition of natural numbers is commutative written in Gallina (listing 1.3).
%
%\begin{lstlisting}[language=haskell, numbers=none, basicstyle=\ttfamily, 
%caption=Inductive Data Type for Natural Numbers,  captionpos=b, xleftmargin=.1\textwidth]
%
%Inductive Natural : Type :=
% | O : Natural
% | Succ : Natural -> Natural
%
%\end{lstlisting}
%
%More precisely, the interpretation is that Natural is a inductive type with two constructors: i) O representing zero,
%and ii) Succ representing successor which takes a Natural number and gives next Natural number.
%
%\fix{Change the Addition into infix symbol + and use + in proofs. It will convey the idea more clearly}
%\begin{lstlisting}[language=haskell, numbers=none, basicstyle=\ttfamily,  caption=Addition function for Natural Numbers,  captionpos=b, xleftmargin=.1\textwidth]
%
% 
%Fixpoint Addition (n m : Natural) : Natural :=
%  match n with
%  | O => m
%  | Succ n' => Succ (Addition n' m)
%  end.
%
%(* Notation for Addition. Now we can use + instead of 
%   writing Addition *)
%Notation "x + y" := (Addition x y)
%            (at level 50, left associativity).
%\end{lstlisting}
%
%We define the addition by pattern matching on first argument \textbf{n}. When \textbf{n} is 
%O (zero), then we sum is \textbf{m}, and if \textbf{n} is \textbf{Succ n'}, then sum is successor of 
%\textbf{n' +  m}.
%
%\begin{lstlisting}[language=haskell, numbers=none, basicstyle=\ttfamily,  caption=Addition function for Natural Numbers,  captionpos=b, xleftmargin=.1\textwidth]
%
%Theorem Addition_by_zero : forall (n : Natural), n + O = n.
%  refine (fix IHa (n : Natural) : n + O = n :=
%            match n as nz return (nz + O = nz) with
%            | O => eq_refl
%            | Succ n' =>
%              let IHn' := IHa n' in
%              eq_ind_r (fun m => Succ m = Succ n') eq_refl IHn'
%            end).
%Qed.
%
%  
%Lemma Successor_addition : forall (n m : Natural),
%    Succ (n + m) = n + (Succ m).
%  refine
%    (fix IHn (n : Natural) : forall m : Natural,
%        Succ (n + m) = n + (Succ m) :=
%       match n as nz return (forall m : Natural,
%                                Succ (nz + m) =
%                                nz + (Succ m)) with
%       | O => fun m : Natural => eq_refl
%       | Succ n' =>
%         fun m : Natural =>
%           eq_ind (Succ (n' + m))
%                  (fun t => Succ (Succ (n' + m)) = Succ t)
%                  eq_refl (n' + (Succ m)) (IHn n' m)
%       end).
%Qed.
%     
%
%    
%Theorem Addition_is_commutative :
%  forall (n m : Natural), n +  m = m + n.
%  refine
%    (fix IHn (n : Natural) : forall m : Natural,
%        n + m = m + n :=
%       match n as nz return (forall m : Natural,
%                                nz + m =
%                                m + nz) with
%       | O => fun m : Natural => eq_ind_r (fun t => m = t)
%                                      eq_refl
%                                      (Addition_by_zero m)
%       | Succ n' =>
%         fun m  =>
%           eq_ind (Succ (m + n'))
%                  (fun t => Succ (n' + m) = t)
%                  (eq_ind_r (fun t => Succ t = Succ (m + n'))
%                            eq_refl (IHn n' m))
%                  (m + (Succ n'))
%                  (Successor_addition m n')
%       end).
%Qed.
%
%
%\end{lstlisting}
%
%
%We need two additional Lemma:
% i) $Addition\_by\_zero$, a proof of n + 0 = 0,
% and ii) $Successor\_addition$, a proof of Succ (n + m) = n + (Succ m) 
% to prove that addition on Natural is commutative ($Addition\_is\_commutative$), 
% 
% One thing that can't escape from the reader's eyes is that the proofs written in Gallina is verbose, and they don't 
% appear anywhere compared to a proof that would have been written by a mathematician. Well, we can lift the burden 
% of verbosity by using tactics provided by Coq; however, there is no universally accepted solution in Coq community 
% for second problem. There has been some research in declarative style proof writing 
% \footnote{www-verimag.imag.fr/~corbinea/ftp/publis/bricks-poster.pdf}, but it is not widely practised in Coq 
% community. The proof of addition on Natural is commutative re-written using tactics (Listing 1.4)
% 
% 
% \begin{lstlisting}[language=haskell, numbers=none, basicstyle=\ttfamily,  caption=Addition function for Natural Numbers,  captionpos=b, xleftmargin=.1\textwidth]
%
%Lemma Addition_by_zero : forall (n : Natural), n + O = n.
%  induction n; cbn; [auto | rewrite IHn; auto].
%Qed.
%
%
%Lemma Successor_addition : forall (n m : Natural),
%    Succ (n + m) = n + (Succ m).
%Proof.
%  induction n; intros m;
%    cbn; [auto | rewrite <- IHn; auto].
%Qed.
%
%
%Theorem Addition_is_commutative :
%  forall (n m : Natural), n +  m = m + n.
%Proof.
%  induction n; intro m;
%    [rewrite Addition_by_zero |
%     rewrite <- Successor_addition;
%     rewrite <- IHn]; auto.
%Qed.
%
%\end{lstlisting}
%
%Section~\ref{sec:motivation} xxxx.\\
%
%
%Section~\ref{sec:relatedwork} yyyy.\\
%
%
%%\section{Motivation}
%%\label{sec:motivation}
%
%
%%\section{Related work}
%%\label{sec:relatedwork}
%%You may reference other papers. For example: 
%%Generational garbage collection~\citep{LH:83,Moon:84,Ungar:84} is perhaps the
%%single most important advance in garbage collection since the first collectors
%%were developed in the early 1960s. (doi: "doi" should just be the doi part, not
%%the full URL, and it will be made to link to dx.doi.org and resolve.
%%shortname: gives an optional short name for a conference like PLDI '08.)
%%
%%
%%
%%
%%
%%\section{Summary}
%%Summary what you discussed in this chapter, and mention the story in next
%%chapter. Readers should roughly understand what your thesis takes about by only reading
%%words at the beginning and the end (Summary) of each chapter.
%
%
%
