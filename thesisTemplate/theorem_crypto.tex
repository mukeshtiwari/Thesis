\chapter{Theorem Prover and Cryptography}
\label{cha:theorem_crypto}
 

A proof assistant or theorem prover is a computer program which assists users in development 
of mathematical proofs. The idea of 
developing mathematical proofs using computer goes back to Automath (automating mathematics)
\citep{deBruijn1983} and LCF \citep{Milner:1972:IAS:942578.807067}. The 
Automath project (1967 until the early 80's)  was initiative of De Bruijn, and the aim of the project was to 
develop a language for expressing mathematical theories which can be verified by aid of computer.  
Automath was first 
practical project to exploit the Curry-Howard isomorphism (proofs-as-programs and formulas-as-types). 
DeBruijn  was likely unaware of this correspondence, and he almost re-invented it.
Automath project can be seen as the precursor of
 proof assistants NuPrl \citep{Constable:1986:IMN:10510} and Coq \citep{Bertot:2004:ITP}.  
 Some other notable  proof assistants are 
 Nqthm/ACl2 \citep{507872}, PVS \citep{Owre:1992:PPV:648230.752639},
 HOL (a family of tools derived from LCF theorem prover) \citep{Slind:2008:BOH:1459784.1459792}
 \citep{Harrison:1996:HLT:646184.682934} \citep{Nipkow:2002:IHP},
 Agda \citep{Norell:2008:DTP:1813347.1813352}, and Lean \citep{10.1007/978-3-319-21401-6_26}.


\textbf{Chapter overview:}
 This chapter is overview of Coq theorem prover and Cryptographic primitives. 
 In the section \ref{sec:problemstatement}, I will give a brief overview of 
 theoretical foundation, calculus of construction (\ref{sec:cc}) and calculus of inductive 
 construction (\ref{sec:cic}), of Coq.  In the section \ref{sec:typeprop}, I will discuss about 
 \texttt{Type} and \texttt{Prop}
 which is very crucial from program extraction point of view.  Our goal during 
 this course of formalization was not only proving the correctness of 
 Schulze method, but extracting a executable OCaml/Haskell code to count 
 ballots.  In the section \ref{sec:deplambda}, I will focus 
 on dependent types and  how it leads to correct by construction paradigm
 by designing a  type safe printf function. 
 Section \ref{sec:gallina} focuses on Coq specification language 
 \texttt{Gallina} with a example showing that why writing proofs using  
 \texttt{Gallina} is difficult and cumbersome, and how it can be eased by 
 using tactics. Finally, in the section  \ref{sec:coqproof}, we will take 
 philosophical route to justify that why should we trust in Coq proofs 
 even though they do not appear anywhere near to a proof written by 
 a human. 


\section{Coq: Interactive Proof Assistant}
\label{sec:problemstatement}
Coq  is an interactive proof assistant (theorem prover) based on
theory of Calculus of 
Inductive Construction \citep{Paulin-Mohring:1993:IDS:645891.671440} which itself is an 
augmentation of Calculus of Construction 
\citep{Coquand:1988:CC:47724.47725} with inductive data-type.  
 

\subsection{Calculus of Construction}
\label{sec:cc}
\subsection{Calculus of Inductive Construction}
\label{sec:cic}
%\fix{Flesh out the details of 
% Calculus of construction and Inductive construction}
% \fix{Write here about syntax and semantics of CIC}
 
 
\subsection{Type vs. Prop: Code Extraction}
\label{sec:typeprop}
 \fix{explain here the difference between Prop and Types. How it affects 
  the code extraction }
  It's good starting point to tell the reader that we have two definitions, 
  one in type and other in prop. Why ? Because Type computes, but it's
  not very intuitive for human inspection while Prop does not compute, 
  but it's very intuitive for human inspection. We have connected that 
  the definition expressed in Type is equivalent to Prop definition. 
  
  \subsubsection{Reification}
  \label{sec:reification}
    
 \subsection{Correct by Construction: Type Safe Printf}
 \label{sec:deplambda}
  One of the highly sought feature of Coq is dependent type, 
  a type which is parametrised by value.  
  The expressiveness of dependent type make it possible
  to express specification at type level. These specifications enables larger 
  set of  logical errors to eliminated at compile time. 
  
 
 Using the expressiveness of dependent type, we construct a type safe version of 
 printf. Our goal is to generate compiler error when the given format string and the type of 
 corresponding input values  
 do not match, e.g. printf "\%d \%s" "hello Coq" 42 should be compiler error, otherwise
 print the string if it type checks, e.g.
 printf "\%s \%d" "hello Coq" 42 should print the string "hello Coq  42".
 The high level idea is to split the printf arguments into two parts: i) format string, 
 and ii) values to be printed, e.g. printf "\%s \%d" "hello Coq" 42 would be split into "\%s \%d", and 
 "hello Coq" 42.  Based on the format string, we design two functions: i) a type level function 
 which takes format string and returns a variadic function type, e.g. 
 on format string "\%s \%d", it would return a function type with 
 signature \texttt{string -> Z  -> string}, and ii) a value level function whose type signature 
 is constructed by the type level function and takes the values to printed as input. If the 
 type of values to be printed matches with type constructed by type level function then 
 we proceed to print the string, otherwise we generate compiler error.  
 


First, we defined a abstract syntax tree, \textit{format}, to make it explicit the characters we 
are interested in format string. The \textit{format\_string} function takes the format string 
and returns the abstract syntax tree. The type level, \textit{interp\_format}, takes the 
abstract syntax tree and returns the function type corresponding to format string.

\begin{verbatim}
(* abstract syntax tree *)
Inductive format :=
| Fend : format
| Fint : format -> format
| Fstring : format -> format
| Fother : ascii -> format -> format.

(* turn the format string into abstract syntax tree *)
Fixpoint format_string (inp : string) : format :=
  match inp with
  | EmptyString => Fend
  | String ("%"%char) (String ("d"%char) rest) => Fint (format_string rest)
  | String ("%"%char) (String ("s"%char) rest) => Fstring (format_string rest)
  | String c rest => Fother c (format_string rest)
  end.


(* construct the type level function from abstract syntax tree *)
Fixpoint interp_format (f : format) : Type :=
  match f with
  | Fint f => Z  -> interp_format f
  | Fstring f => string -> interp_format f
  | Fother c f => interp_format f
  | Fend => string
  end.
\end{verbatim}


\noindent
The \textit{interp\_format} function returns a function type 
(\texttt{Z -> string -> string -> string})  on the (abstract syntax tree of) 
format string "\%d \%s \%s" 

\begin{verbatim}
Eval compute in interp_format (format_string "%d %s %s").
(* = Z -> string -> string -> string
     : Type *)
\end{verbatim}

Now, we construct a value level function, \textit{interp\_value}, whose type 
is constructed by type level function, and it will take the values to be printed as input.
The type of values to print should match the type constructed by type level 
function for successful type checking otherwise it will be type error. 

\begin{verbatim}
(* value level function whose type is constructed on fly by interp_format 
    function *)
Fixpoint interp_value (f : format) (acc : string) : interp_format f :=
  match f with
  | Fint f' => fun i => interp_value f' (acc ++ of_Z i)
  | Fstring f' => fun i => interp_value f' (acc ++ i)
  | Fother c f' => interp_value f' (acc ++ String c EmptyString)
  | Fend => acc
  end.
\end{verbatim}

\noindent
Finally, we define the printf function, and evaluate it on two inputs: 
i)  printf "\%d \%s" "hello Coq" 42, and ii)  printf "\%d \%s" 42 "hello Coq".

\begin{verbatim}
Definition printf s := interp_value (format_string s) "".           

Eval compute in  printf "\%d \%s" "hello Coq"%string 42.
(* Error: The term ""hello Coq"%string" has type "string" 
while it is expected to have type "Z". *)

Eval compute in  printf "\%d \%s" 42 "hello Coq"%string. 
(*  "\0b101010 \hello Coq"%string. The number 
42 is printed in binary *)                            
\end{verbatim}
The first input, printf "\%d \%s" "hello Coq" 42, is type error because 
printf "\%d \%s" returns a value level function whose  type is Z -> string -> string, but 
the type of first argument, "hello Coq", is string which does not unifies with Z,
while second one is successfully printed as string. 

  
  

 
 \subsection{Gallina: The Specification Language}
 \label{sec:gallina}
  The example, type safe printf function, I gave in previous 
  section was encoded in Coq's specification language Gallina. 
  Gallina is a highly expressive specification 
  language for development of mathematical theories and proving the    
  theorems about these  theories; however, writing proofs in Gallina
  is very tedious and cumbersome. It's not suitable for large proof 
  development, and to ease the proof development Coq also provides 
  tactics.  The user interacting with Coq theorem prover applies these 
  tactics to build the  Gallina term  which otherwise would  
  be very laborious.
  
 We have written two proofs that addition on natural number is commutative. 
 First proof, \textit{addition\_commutative\_gallina}, is written using 
 Gallina, while second proof, \textit{addition\_commutative\_tactics}, is written 
 using the tactics.  In general, we write programs directly in Gallina and use tactics 
 to prove properties about the programs, but there is no fixed rule and tactics 
 can be used to write functions with dependent types.
\begin{verbatim}
(* proof written using Gallina *)
Lemma addition_commutative_gallina : forall (n m : nat), n + m = m + n.
refine
      (fix Fn (n : nat) : forall m : nat, n + m = m + n :=
        match n as n0 return (forall m : nat, n0 + m = m + n0) with
        | 0 => fun m : nat => 
           eq_ind_r (fun n0 : nat => m = n0) eq_refl (Nat.add_0_r m)
        | S n' =>
          fun m : nat =>
            eq_ind_r (fun n0 : nat => S n0 = m + S n')
                     (eq_ind_r (fun n0 : nat => S (m + n') = n0) 
                     eq_refl (Nat.add_succ_r m n')) (Fn n' m)
        end).
Qed.

(* proof written using tactics *)
Lemma addition_commutative_tactics : forall (n m : nat), n + m = m + n.
  induction n; intro m; simpl; try omega.
Qed.
\end{verbatim}



 \subsection{Trusting Coq proofs}
 \label{sec:coqproof}
  In general, Coq proofs are nowhere similar to a mathematical 
  proof written by trained mathematician. Also, these proofs 
  are verbose and fairly long, so a 
  very fundamental question is that why should we 
  accept or believe in a proof written in Coq \citep{pollack1998believe}?  The answer of 
	accepting or trusting Coq proos is two fold:
  i) is the logic (CIC) sound?, and ii) is the implementation correct?
  The logic has already been reviewed by many peers and proved correct 
  using some meta-logic, so the answer of our question about trusting Coq proof 
  hinges on the implementation. 
  Coq implementation (written in OCaml) itself can be partitioned into two parts: 
  i) type checker (small kernel), 
  and ii) tactic language to build the proofs.
  We lay our trust in type checker, because it's small kernel and can be 
  manually inspected. If there
  is a bug in tactic language, which often is the case, then build proof would 
  not pass the type checker.  Also, we can use the publicly available proof 
  checkers written by experts and inspected by many others. To increase the 
  confidence, there have been 
  efforts to certify type checker \citep{Appel2003}
  \citep{barras1996coq}, verifying meta theory of one proof system 
  in other \citep{10.1007/978-3-319-08970-6_3}, self certificate of 
  theorem prover \citep{10.1007/11814771_17}. However, no system can 
  prove its own consistency (G{\"o}del's second incompleteness theorem), so
  trusting human judgement is inevitable.
  
  
\section{Summary} 
  Paves the path to Cryptography. 
    
\section{Cryptography}
    Write some basic crypto stuff
    
    \subsection{Homomorphic Encryption}
     Add the details of 
     homomorphic encryption 
     \subsubsection{El-Gamal Encryption Scheme}
        Give both additive and multiplicative
     \subsubsection{Pallier Encryption Scheme}
        Write some description
     \subsection{Commitment Schemes}   
        \subsubsection{Hash Based Commitment Scheme}
        \subsubsection{Discrete Logarithm Based Commitment Scheme}
         Pedersen's Commitment Scheme
     \subsection{Zero Knowledge Proof}
  		Details from 
  	 \subsection{Sigma Protocol : Efficient Zero Knowledge Proof}
  



\section{Summary}










%
%%\label{sec:problemstatement}
%Now I give a small example which defines natural number, addition of two natural numbers, and 
%proof that addition over natural number is commutative.   We can define 
%natural number in Coq using inductive data type (listing 1.1), addition of the natural numbers 
%(listing 1.2), and proof that addition of natural numbers is commutative written in Gallina (listing 1.3).
%
%\begin{lstlisting}[language=haskell, numbers=none, basicstyle=\ttfamily, 
%caption=Inductive Data Type for Natural Numbers,  captionpos=b, xleftmargin=.1\textwidth]
%
%Inductive Natural : Type :=
% | O : Natural
% | Succ : Natural -> Natural
%
%\end{lstlisting}
%
%More precisely, the interpretation is that Natural is a inductive type with two constructors: i) O representing zero,
%and ii) Succ representing successor which takes a Natural number and gives next Natural number.
%
%\fix{Change the Addition into infix symbol + and use + in proofs. It will convey the idea more clearly}
%\begin{lstlisting}[language=haskell, numbers=none, basicstyle=\ttfamily,  caption=Addition function for Natural Numbers,  captionpos=b, xleftmargin=.1\textwidth]
%
% 
%Fixpoint Addition (n m : Natural) : Natural :=
%  match n with
%  | O => m
%  | Succ n' => Succ (Addition n' m)
%  end.
%
%(* Notation for Addition. Now we can use + instead of 
%   writing Addition *)
%Notation "x + y" := (Addition x y)
%            (at level 50, left associativity).
%\end{lstlisting}
%
%We define the addition by pattern matching on first argument \textbf{n}. When \textbf{n} is 
%O (zero), then we sum is \textbf{m}, and if \textbf{n} is \textbf{Succ n'}, then sum is successor of 
%\textbf{n' +  m}.
%
%\begin{lstlisting}[language=haskell, numbers=none, basicstyle=\ttfamily,  caption=Addition function for Natural Numbers,  captionpos=b, xleftmargin=.1\textwidth]
%
%Theorem Addition_by_zero : forall (n : Natural), n + O = n.
%  refine (fix IHa (n : Natural) : n + O = n :=
%            match n as nz return (nz + O = nz) with
%            | O => eq_refl
%            | Succ n' =>
%              let IHn' := IHa n' in
%              eq_ind_r (fun m => Succ m = Succ n') eq_refl IHn'
%            end).
%Qed.
%
%  
%Lemma Successor_addition : forall (n m : Natural),
%    Succ (n + m) = n + (Succ m).
%  refine
%    (fix IHn (n : Natural) : forall m : Natural,
%        Succ (n + m) = n + (Succ m) :=
%       match n as nz return (forall m : Natural,
%                                Succ (nz + m) =
%                                nz + (Succ m)) with
%       | O => fun m : Natural => eq_refl
%       | Succ n' =>
%         fun m : Natural =>
%           eq_ind (Succ (n' + m))
%                  (fun t => Succ (Succ (n' + m)) = Succ t)
%                  eq_refl (n' + (Succ m)) (IHn n' m)
%       end).
%Qed.
%     
%
%    
%Theorem Addition_is_commutative :
%  forall (n m : Natural), n +  m = m + n.
%  refine
%    (fix IHn (n : Natural) : forall m : Natural,
%        n + m = m + n :=
%       match n as nz return (forall m : Natural,
%                                nz + m =
%                                m + nz) with
%       | O => fun m : Natural => eq_ind_r (fun t => m = t)
%                                      eq_refl
%                                      (Addition_by_zero m)
%       | Succ n' =>
%         fun m  =>
%           eq_ind (Succ (m + n'))
%                  (fun t => Succ (n' + m) = t)
%                  (eq_ind_r (fun t => Succ t = Succ (m + n'))
%                            eq_refl (IHn n' m))
%                  (m + (Succ n'))
%                  (Successor_addition m n')
%       end).
%Qed.
%
%
%\end{lstlisting}
%
%
%We need two additional Lemma:
% i) $Addition\_by\_zero$, a proof of n + 0 = 0,
% and ii) $Successor\_addition$, a proof of Succ (n + m) = n + (Succ m) 
% to prove that addition on Natural is commutative ($Addition\_is\_commutative$), 
% 
% One thing that can't escape from the reader's eyes is that the proofs written in Gallina is verbose, and they don't 
% appear anywhere compared to a proof that would have been written by a mathematician. Well, we can lift the burden 
% of verbosity by using tactics provided by Coq; however, there is no universally accepted solution in Coq community 
% for second problem. There has been some research in declarative style proof writing 
% \footnote{www-verimag.imag.fr/~corbinea/ftp/publis/bricks-poster.pdf}, but it is not widely practised in Coq 
% community. The proof of addition on Natural is commutative re-written using tactics (Listing 1.4)
% 
% 
% \begin{lstlisting}[language=haskell, numbers=none, basicstyle=\ttfamily,  caption=Addition function for Natural Numbers,  captionpos=b, xleftmargin=.1\textwidth]
%
%Lemma Addition_by_zero : forall (n : Natural), n + O = n.
%  induction n; cbn; [auto | rewrite IHn; auto].
%Qed.
%
%
%Lemma Successor_addition : forall (n m : Natural),
%    Succ (n + m) = n + (Succ m).
%Proof.
%  induction n; intros m;
%    cbn; [auto | rewrite <- IHn; auto].
%Qed.
%
%
%Theorem Addition_is_commutative :
%  forall (n m : Natural), n +  m = m + n.
%Proof.
%  induction n; intro m;
%    [rewrite Addition_by_zero |
%     rewrite <- Successor_addition;
%     rewrite <- IHn]; auto.
%Qed.
%
%\end{lstlisting}
%
%Section~\ref{sec:motivation} xxxx.\\
%
%
%Section~\ref{sec:relatedwork} yyyy.\\
%
%
%%\section{Motivation}
%%\label{sec:motivation}
%
%
%%\section{Related work}
%%\label{sec:relatedwork}
%%You may reference other papers. For example: 
%%Generational garbage collection~\citep{LH:83,Moon:84,Ungar:84} is perhaps the
%%single most important advance in garbage collection since the first collectors
%%were developed in the early 1960s. (doi: "doi" should just be the doi part, not
%%the full URL, and it will be made to link to dx.doi.org and resolve.
%%shortname: gives an optional short name for a conference like PLDI '08.)
%%
%%
%%
%%
%%
%%\section{Summary}
%%Summary what you discussed in this chapter, and mention the story in next
%%chapter. Readers should roughly understand what your thesis takes about by only reading
%%words at the beginning and the end (Summary) of each chapter.
%
%
%
