\chapter{Scrutiny Sheet : Software Independence}
\label{cha:software_independence}

\epigraph{Somewhere inside of all of us is the power to change the world.} 
{\textit{Roald Dahl }}

\section{Introduction}


One of the major disadvantage of introducing cryptography 
to achieve privacy and verifiability, encryption to make the 
content of ballot private and zero-knowledge-proof for verification of claims, makes the verification 
process cumbersome. As a consequence, the verification process (checking the scrutiny sheet) is only accessible 
to tiny fraction of representative population, cryptographers, results into a sharp decrease in number of scrutineers. 
While it is not very difficult to find cryptographers in any economy, 
they are not in abundance, and in addition, they are not representative of democracy. 
In order to increase the number of scrutineers, we follow the route of providing a formally verified open-source 
reference certificate checker, which anyone can inspect and run on the election data. 
  The rationale behind formally verifying the certificate checker is \emph{correctness}
  and open sourcing is to gain the public trust  via scrutiny or openness.  
  For example, consider a scenario where we do not provide the reference checker,
  then how 
  likely would it be for community/voters to develop the 
  verified checker? Moreover, assuming that we publish one unverified certificate hecker,
  what would happen if it returns false on a valid certificate because of its own bug? 
  Both situations, off course, would be a devastating situation, so not only we 
  should provide a reference certificate checker, but it should also be a formally verified one. 
  Additionally, a formally verified reference certificate checker would open the gate for
  debate in case of someone's implementation for checking certificate diverges from the reference checker.  
In the case of diverging situation, there are two possibility, either the reference checker is verified 
using wrong assumption,  or the implementation itself is wrong.  The first situation is certainly 
not very pleasant because it would deteriorate the public trust in the system, but nonetheless, it is always
good to  have openness in democracy to make it more strong. 
  
  
  
  At this point of time, the astute reader can criticize us that the source code of formally verified certificate checker should be 
  inspected by someone having the expertise of cryptography and formal verification (logic) 
  to see if the verification has been carried out diligently. We sincerely accept the criticism of the 
  reader that this is indeed the case, but what makes this effort  worthwhile is 
  the increased ability of voters to verify the election by themselves by 
  simply running the checker, which has been checked by a community having the 
  expertise of cryptography and logic. 

\textbf{Chapter Outline:} 



In this chapter, we sketch all the concepts required to develop a verified certificate checker for the certificate we generated 
in the last chapter.  We have already explained our certificate in the section \ref{sec:extract}, but intuitively, 
checking our certificate amounts to prove that  homomorphic margin has been computed correctly and zero-knowledge-proof for each claim checks out, which is honest decryption, 
a ballot has been permuted by the same permutation whose commitment is published (commitment consistent shuffle \citep{Wikstrom:2009:CPS}), and 
homomorphic computing of final tally.  We will give a formal proof of honest decryption, Pedersen's commitment, and homomorphic computing of 
tally; however, we will not prove the  shuffle (it is still ongoing work).  

We have taken a minor detour in this chapter 



\section{Algebraic Structures: Builing Blocks}
The basic building blocks any cryptographic system are algebraic structures, specifically cyclic group of prime order, field and vector space. In general, 
we do not need vector space, and group and field are sufficient for most of the cryptographic purposes. However,
vector space  of a cyclic group of prime order over the field of integers modulo the same order is nicer to work 
because multiplying a group element by a field element can be abstracted over scalar multiplication. 

\begin{definition}[Group] 
A group is a set $G$, with a binary operator $* : G \rightarrow G \rightarrow G$, identity element $e$, and inverse operator $inv : G \rightarrow G$ such 
    that the following laws hold:  \end{definition} 
    \begin{itemize}
     \item \texit{Associativity}: $\forall$  a b c $\in G,$  $a * (b * c) = (a * b) * c$
    \item \texit{Closure}: $\forall$ a b $\in G,$  $a * b \in G$
    \item \texit{Inverse Element}: $\forall$ a $\in G$ $\exists$ $a^{-1} \in G$, such that $a * a^{-1} = a^{-1} * a = e$. $a^{-1}$ is called inverse of $a$ ($inv$ a).
    \item \texit{Identity}: $\forall$ a $\in G,$  $a * e = e * a  = a$
    \end{itemize}
  
    \noindent
    If the group is commutative, i.e. $\forall$ a b $\in  G,$  $a * b = b * a$, then we call it abelian group.  We can represent the abelian group in Coq by using the 
    typeclass functionality. 
 
 
 \begin{verbatim}

Record AbelGroup (G : Type) (Hdec : forall x y : G, {x = y} + {x <> y}) 
       (dot : G -> G -> G)  (inv : G -> G) (e : G) :=
  {
    dot_associativity : forall x y z, 
      dot x (dot y z) = dot (dot x y) z;
    dot_left : forall x, dot x e = x;
    dot_right : forall x, dot e x = x;
    left_inverse : forall x, dot (inv x) x = e;
    right_inverse : forall x, dot x (inv x) = e;
    commutative : forall x y, dot x y = dot y x
  }.
  
\end{verbatim}    

\noindent
Our Coq encoding is slight different from the definition of the group we gave above, mainly that \textit{G : Type} "read it as A has the type Type" and 
\textit{(Hdec : forall x y : G, {x = y} + {x <> y})}. Because of theoretical foundations of Coq lies in type theory, every term in Coq has to have a type;
hence we need to explicitly state the type of term $G$, and we assume a decidable equality $Hdec$ on the elements of $G$.  

\begin{definition}[Field] 
A field  is a set $F$, with two binary operator $+ : F \rightarrow F \rightarrow F$,  and $\cdot : F \rightarrow F \rightarrow F$, 
two identity element $0$ and $1$, and two unary operator $- : F \rightarrow F$, $1/ : F \rightarrow F$  such that:
\end{definition} 
 \begin{itemize}
 \item (F, +, 0, -) forms an abelian group.
 \item (F - $\lbrace 0 \rbrace$, $\cdot$, 1, 1/) forms an abelian group.
 \item $\cdot$ distributes over +.
 \end{itemize}
 
 
 \fix{rewrite it}
\begin{Definition}[Vector Space}
A vector  space is a set 
 
 \begin{definition}[Vector Space]
	A vector space is a set $G$ with a binary operator $\cdot$, identity 
	element $e$ in $G$, a unary operator $-_G$, and a set $F$ 
	with two binary operators $+$ and $*$, two identity elements $0$ and $1$ in $F$,
	two unary operators $-_F,1/$, and binary (exponentiation) operator ${-}^{-}$  such that:
        \begin{description}
		\item[\rm Abelian group:] $\langle G, \cdot, e, -_G \rangle$ form an Abelian Group
		\item[\rm Field:] $\langle F, +, *, 0, 1, -_F, 1/ \rangle$ form a field
		\item[\rm Distributivity with respect to vector
                  addition:] ~\\
                  $\forall r \in F, \forall x, y \in G, (x \cdot y)^r = x^r \cdot y^r$
		\item[\rm Distributivity with respect to field addition:] ~\\
                     $\forall r, s \in F, \forall x \in G, x^{r+s} = x^r \cdot x^s$
		\item[\rm Compatibility:] $\forall r, s \in F, \forall x \in G, x^{r*s} = x^{r^s}$
		\item[\rm Identity:] $\forall x \in G, x^1 = x$
		\item[\rm Annihilator:] $\forall x \in G, x^0 = 1$
        \end{description}
\end{definition}
 
\begin{verbatim}

Record VectorSpace (G F : Type)
       (Gdot : G -> G -> G) (Sop : G -> F -> G)
       (Hfdec : forall x y : F, {x = y} + {x <> y})
       (Hgdec :  forall x y : G, {x = y} + {x <> y})
       (Fadd Fsub Fmul Fdiv : F -> F -> F) 
       (Fopp Finv : F -> F)
       (Fzero Fone : F)
       (Gone : G)
       (Ginv : G -> G) :=
  {
    vs_field : @field_theory F Fzero Fone Fadd
             Fmul Fsub Fopp Fdiv Finv (@eq F);
    module_abegrp :  @AbelGroup G Hgdec Gdot Ginv Gone;
    mod_dist_Gdot : forall (r : F) (x y : G),
        Sop (Gdot x y) r = Gdot (Sop x r) (Sop y r);
    mod_dist_Fadd : forall (r s : F) (x : G),
        Sop x (Fadd r s) = Gdot (Sop x r) (Sop x s);
    mod_dist_Fmul : forall (r s: F) (x : G),
        Sop x (Fmul r s) = Sop (Sop x s) r;
    mod_id : forall (x : G), Sop x Fone = x;
    mod_ann : forall (x : G), Sop x Fzero = Gone;
  }.

\end{verbatim}

\section{Commitment Schemes}


\section{Sigma Protocol: Efficient Zero-Knowledge-Proof}
A sigma protocol is a two party protocol, a prover $P$ and a verified $V$, where prover $P$ try to convince the $V$ that he 
holds a private input $x$ for some public input $w$ such that a binary relation $R$ holds, i.e. $(x, w) \in R$.  Sigma protocol, 
in general, is a three step protocol:
\begin{enumerate}
\item Initialisation: $P$ generates a random message $r$, commits it, and send the committed message to $V$
\item Challenge: $V$ generates a random message $c$, and sends it to $V$
\item Response: $P$ sends a response $z$ to $V$
\end{enumerate} 

\noindent
Upon receiving the response $z$, $V$ either accepts the proof or rejects the proof.  Now we define the sigma protocol in 
Coq as:
\begin{verbatim}
Record SigmaProtocol (Statement : Type) (* statement x *)
       (Witness : Type) (* witness w *)
       (Rel : Statement -> Witness -> bool) (* decidable relation *)
       (RandCoin : Type) (* random coin of prover*) 
       (Commitment : Type) (* commitments *)
       (Challenge : Type) (* random challenges of verifier *) 
       (Response : Type) (* response *) :=
  MkSigma 
    {
      (* Initial commitment send by the prover *)
      initial : Statement -> Witness -> RandCoin  -> 
         Statement * Commitment;
      (* Randomness send by the verifier.  *)     
      challenge : Statement * Commitment -> Challenge -> 
         Statement * Commitment * Challenge;
      (* response generate by prover *)
      response : Statement * Commitment * Challenge -> 
        Witness -> RandCoin -> 
        Statement * Commitment * Challenge * Response; 
      (* check the response *)
      verify:  Statement * Commitment * Challenge * Response -> bool;
      (* Simulator *)
      simulator : Statement -> Challenge -> Response ->
        Statement * Commitment * Challenge * Response;
      (* Extractor *)
      extractor : Challenge -> Response -> Challenge -> 
         Response -> Witness;
      
      (* Completness *)
      Completness : forall (s : Statement) (w : Witness) (r : RandCoin)
                      (e : Challenge),
          Rel s w = true ->
          verify (response (challenge (initial s w r) e) w r) = true;
                                       
      (* Special Soundness *)
      Special_Soundness : forall s c e1 e2 r1 r2, 
        verify (s, c, e1, r1) = true ->
        verify (s, c, e2, r2) = true ->
        exists w,  w = extractor e1 r1 e2 r2 /\ Rel s w = true;
      
    }.

\end{verbatim}

\noindent
Our definition of sigma protocol is almost complete except we have not given 
the special honest verifier zero knowledge proof axiom.  Recall that special honest 
verifier zero knowledge proof amounts to a probabilistic polynomial time simulator 
$S$ which would generate a proof transcript $(a, e, r)$ for any given statement 
$s$ and challenge $e$ for some relation $R$ with same probability distribution as if there 
were a real conversation between a prover $P$ and a verifier $V$ 
for the statement $s$ and challenge $e$ such that $(s, w) \in  R$.
Informally, the real proof transcript depends on statement $s$, witness $w$, 
while the simulated proof transcript depends on statement $s$ and challenge $e$. 
(simulator does have not access to witness $w$, so to generate a accepting 
proof just by using $s$ and $e$, it uses a concept call rewinding  


One important point to note that simulator does not have the access of 
witness $w$, so in order to generate a accepting proof transcript, 
it will first choose the challenge $e$ and response $r$ randomly, and generate 
the commitment. 

The zero-knowledge property means that "whatever the verifier outputs from this interaction, he could have generated without interacting at all". If that's true, then the interaction must not have conveyed any meaningful "knowledge" to the verifier.



If we were doing probabilistic reasoning, we could have represent the real view and 
simulator's view as following:
\begin{verbatim}


\end{verbatim}




\noindent
\textbf{Completeness:} When $P$ and $V$ follow the protocol, then $V$ accepts the proof. In Coq formulation:
\begin{verbatim}
 Axiom completeness : forall (x : PubInput) (w : Witness) 
          (r : RandCoin) (com : Commitment) 
          (cha : Challenge) (res : Response),
          Rel x w = true -> com = initial r -> 
          res = response w r cha ->
          check x com cha res = true.
\end{verbatim}

\noindent
The correctness axiom is mere formulation of what it means to be $P$ and $V$ follows the protocol. 
All it says that for every given public input $x$, witness $w$, random coin toss $r$ of $P$, 
commitment $c$, challenge $chal$ of $V$,  and response $res$, if the relation $Rel$ $x$ $w$ holds,
commitment $com$ depends on the random coin toss $r$,  response $res$ depends on 
witness $w$ and random coin $r$ and challenge $cha$, then $v$ always accepts the proof, i.e. 
$check$ returns true based on public inputs. 



\subsection{Discrete Log}
\subsection{Honest Decryption is Diffie Hellman Tuple}

\section{Homomorphic Tally}
We encrypt each entry in our ballot by additive ElGamal encryption. 

\begin{verbatim}
  
 elGamal_enc (g h : G) (m : G) (r : G) := (g^r, g^m * h^r)
 elGamal_dec (
 matrix_mult (rMargin : Matrix cand_all cand_all (G * G) := pointwise multliplication
 
\end{verbatim}



\section{IACR 2018 Election}



\section{Summary}
In this chapter, we have sketch the ideas for developing a formally verified certificate checker. 

\begin{enumerate}
\item Diffie-Hellman Tuple for honest decryption
\item Homomorphic encryption
\item Sigma Protocol
\item Pedersan Commitment 
\item Wikstrom shuffle 
\end{enumerate}





\begin{enumerate}
\item Need for Scrutiny sheet (Electronic voting)
\item General Structure of Scrutiny sheet
\item How to verify it
\item Extracting a OCaml code
\item Why should we trust the extracted code
\item Bits and pieces need to write scrutiny checker
\item Coq formalization
\item Explain little bit about Coq
\item Why do we need scrutiny checker
\item 
\end{enumerate}



We give a brief overview of the needed concepts to understand our scrutiny sheet.


























        

  
\section{Summary}
   Write some advantage of proof checker for certificates.
   To create the mass scrutineers, all we need is a simple proof checker
   which would take proof certificate as input and spit true or false.
   If it's true then we accept the outcome of election otherwise something 
   wrong.
 










































   
   
   
   
   
   