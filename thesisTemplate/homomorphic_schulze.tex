\chapter{Homomorphic Schulze Algorithm : Axiomatic Approach}
\label{cha:homormorphic_schulze}

\epigraph{Be melting snow. Wash yourself of yourself.} 
{\textit{Rumi}} 

\section{Introduction}
As we stated in the  summary of last chapter that plaintext could lead to 
privacy problems, e.g. ballot identification (italian attack) \cite{Otten}. 
In this chapter, we will try to achieve privacy by using encryption, (tallied-as-cast) 
verifiability by using zero knowledge proof, and correctness of implementation 
by proving the correctness properties inside the Coq theorem prover. 
One important point to note that we do not formalize any cryptographic primitive inside the Coq, but 
took an axiomatic approach, i.e. we assumed the existence of cryptographic 
primitives and postulated their correctness property (axiomatisation of 
cryptographic primitives). We took the axiomatic approach 
because our goal was not to formalize cryptographic primitives, but use these primitives
to conduct an election which has all three ingredient privacy, verifiability, 
and correctness. We then obtain, via program extraction, a
provably correct implementation of vote counting, that we turn
into executable code by providing implementations of the primitives
based on a standard cryptographic library (Unicrypt). 
We conclude by presenting
experimental results, and discuss trust the trust base, security and
privacy as well as the applicability of our work to real-world
scenarios. 




\textbf{Chapter Outline:} In the Section \ref{sec:verifiable_homomorphic}, 
we discuss the technique to achieve verifiable homomorphic tally. In order to do so, 
we discuss why do we need our ballot to have a matrix representation 
and not a ranking function. Moreover, we discuss the concept 
of validity of a ballot, which comes naturally with matrix representation, 
steps of homomorphic counting, and cryptographic primitives needed 
to achieve all the required functionality. Section \ref{sec:realisation} 
takes a step forward and makes every concept from the previous section
concrete using the Coq theorem prover. One important point 
in this section is our inductive data type \textit{ECount}
augmented with verification data in form of zero-knowledge-proof 
for various claims made during the counting 
($ECount$ is conceptually similar to the $Count$ (Section \ref{sec:inductive_type}), but 
in terms of data, $ECount$ has state data related to counting and verification data
in form of zero-knowledge proof related to claims made by us, while $Count$ 
has just state data).  In the Section \ref{sec:correct}, we present
our main theorem which states that for any set of given encrypted ballots, 
a winner can always be found. Apart from the main theorem, this section 
also incorporates the proof of correctness by stating 
the winners produced by encrypted ballots are same as 
 the plain-text ballots (Section \ref{sec:all_winners}) if 
 encrypted ballots are aligned (decrypt) with plain-text ballot. 
 Section \ref{sec:extract} focuses on extraction, instantiating 
 the cryptographic primitives with UniCrypt library, and 
 experimental results. Finally, Section \ref{sec:summary_homomorphic} 
 highlights our assumptions, scalability issues, the 
 goals we achieved and the goals we missed. 


 


Secure elections are a balancing act between integrity and privacy:
achieving either is trivial but their combination is notoriously hard.
One of the key challenges faced by both paper based and electronic
elections is that results must substantiated with
verifiable evidence of their correctness while retaining the secrecy
of the individual ballot \citep{Bernhard:2017:PES}. 
The combination of privacy and integrity can be realised using cryptographic techniques, where
encrypted ballots (that the voters themselves cannot decrypt) are
published on a bulletin board, and the votes are then processed, and
the correctness of the final tally is substantiated, using
homomorphic encryption \citep{Hirt:2000:ERF} and verifiable shuffling
\citep{Bayer:2012:EZK}. (Separate techniques exist to prevent ballot
box stuffing and to guarantee cast-as-intended.)
Integrity can then be guaranteed by means of Zero Knowledge Proofs
(ZKP),
first studied by Goldwasser, Micali, and Rackoff~\citep{Goldwasser:1985:STOC}.
Informally, a ZKP is a probabilistic and interactive proof where one
entity interacts with another such that the interaction provides
no information other than that the statement being proved is true with
overwhelming probability. 
Later results~\citep{Ben-Or:1988:CRYPTO,Goldreich:1991:ACM}
showed that 
all problems for which solutions can be efficiently verified have zero knowledge
proof (In practice, sigma protocol is used prove the knowledge of witness $w$ for a public input $x$, 
and it is required to be zero-knowledge against the honest verifier).

  
 \section{Verifiable Homomorphic Tallying}
\label{sec:verifiable_homomorphic}
The realisation of verifiable homomorphic tallying that we are about to
describe follows the same two phases as the algorithm (Section \ref{sec:schulze_algorithm}): 
We first homomorphically compute the margin matrix from encrypted ballots, and then compute
winners on the basis of the (decrypted) margin. Moreover, the computation also
produces a verifiable certificate that leaks no information about
choices in individual ballots other than the (final) margin matrix, which in
turn leaks no information about individual ballots if the number of
voters is large enough. 


\smallskip\noindent\emph{Format of Ballots.} Recall that in preferential voting
schemes, ballots are rank-ordered lists of candidates. For the
Schulze Method, we require that all candidates are ranked, and two
candidates may be given the same rank. That is, a ballot is most
naturally represented as a function $b: C \to Nat$ that assigns a
numerical rank to each candidate, and the computation of the margin
amounts to computing the sum
\[ m(x, y) = \sum_{b \in B} \begin{cases} +1 & b(x) > b(y) \\ 0 &
b(x) = b(y) \\ -1 & b(x) < b(y) \end{cases} \]
where $B$ is the multi-set of ballots, and each $b \in B$ is a
ranking function $b: C \to Nat$ over a (finite) set $C$ of
candidates. 

Ideally, we could have copied the same ballot structure in a homomorphic Schulze method, 
but encrypting the choices, i.e. the ballot would have been represented as $b: C \to EncryptedNaturalNumber$
where $EncryptedNaturalNumber$ is the encrypted representation of a choice (natural number).
However, we note that this representation of ballots is not well suited for
homomorphic computation of the margin matrix as practically feasible
homomorphic encryption schemes do not support comparison operators
and case distinctions as used in the formula above (to the best of our knowledge).

We instead represent ballots as candidate indexed matrices
$b(x, y)$ where $b(x, y) = +1$ if $x$ is preferred
over $y$, $b(x, y) = -1$ if $y$ is preferred over $x$ and $b(x, y) =
0$ if $x$ and $y$ are equally preferred. The downside of this representation 
is that it takes $O(n^2)$ space to represent a ballot where $n$ is the number 
of candidate participating in election. 

While the advantage of the first representation is that each ranking
function is necessarily a valid ranking and is linear space ($O(n))$) in the number 
of candidates, $n$, the advantage of the matrix 
representation is that the computation of
the margin matrix is simple, that is
\[ m(c, d) = \sum_{b \in B} b(x, y) \]
where $B$ is the multi-set of ballots (in matrix form), and can
moreover be transferred to the encrypted setting in a straight
forward way: if ballots are matrices $e(x,y)$ where $e(x,y)$ is the
encryption of an integer in $\lbrace -1, 0, 1 \rbrace$, then
\begin{equation}\label{eqn:enc-mm}
encm = \bigoplus_{encb \in EncB} encb(x, y) 
\end{equation}
where $\oplus$ denotes homomorphic addition, $encb$ is an encrypted
ballot in matrix form (i.e. decrypting $encb(x, y)$ indicates
whether $x$ is preferred over $y$), and $EncB$ is the multi-set of
encrypted ballots. The disadvantage is that we need to verify that a
matrix ballot is indeed valid, that is
\begin{itemize}
\item that the decryption of $encb(x, y)$ is indeed one of $1, 0$ or
$-1$
\item that $encb$ indeed corresponds to a ranking function.
\end{itemize}

\noindent
Indeed, to achieve verifiability, we not only need \emph{verify}
that a ballot is valid, we also need to \emph{evidence} its validity
(or otherwise) in the certificate.  

\smallskip\noindent\emph{Validity of Ballots.} By a plaintext
(matrix) ballot
we simply mean a function $b: C \times C \to Z$,
where $C$ is the (finite) set of candidates. A 
plaintext ballot $b(x, y)$ 
is \emph{valid} if it is induced by a ranking function, i.e.
there exists a function $f: C \to Nat$ such that $b(x, y) = 1$ if
$f(x) < f(y)$, $b(x, y) = 0$ if $f(x) = f(y)$ and $b(x, y) = -1$ if
$f(x) > f(y)$. A \emph{ciphertext (matrix) ballot} is a function
$encb: C \times C \to CT$ (where $CT$ is a chosen set of
ciphertexts), and it is valid if its decryption,  i.e. the plaintext
ballot $b(x, y)  = dec(encb(x, y))$ is valid (where $dec$ denotes
decryption).

For a plaintext ballot, it is easy to decide whether it is
valid (and should be counted) or not (and should be discarded). We
use shuffles (ballot permutations) to evidence the validity of
encrypted ballots. One observes that a matrix ballot is valid if and
only if it is valid after permuting both rows and columns with the
same permutation. That is, $b(x,y)$ is valid if and only if $b'(x,y)$
is valid, where
\[ b'(x,y) = b(\pi(x), \pi(y)) \]
and $\pi: C \to C$ is a permutation of candidates. (Indeed, if $f$
is a ranking function for $b$, then $f \circ \pi$ is a ranking
function for $b'$). As a consequence, we can evidence the validity
of a ciphertext ballot $encb$ by
\begin{itemize}
  \item publishing a shuffled version $encb'$ of $encb$, that is
  shuffled by a secret permutation, together with
  evidence that $encb'$ is indeed a shuffle of $encb$
  \item publishing the decryption $b'$ of $encb'$ together with
  evidence that $b'$ is indeed the decryption of $encb'$.
\end{itemize}

\noindent
We use zero-knowledge proofs (ZKP) in the style of \citep{DBLP:conf/africacrypt/TereliusW10}
to evidence the correctness of the shuffle, and zero-knowledge
proofs of honest decryption \citep{DBLP:conf/crypto/ChaumP92} to evidence
correctness of decryption. This achieves ballot secrecy as
the (secret) permutation is never revealed.


In summary, the evidence of correct (homomorphic) counting starts
with an encryption of the zero margin $encm$, and for each
ciphertext ballot $encb$ contains
\begin{enumerate}
\item \label{it:shuff} a shuffle of $encb$ together with a ZKP of 
correctness
\item decryption of the  shuffle, together with a ZKP of
correctness
\item \label{it:upd-marg} the updated margin matrix, if the decrypted ballot
was valid, and
\item the unchanged margin matrix, if the decrypted
ballot is not valid.
\newcounter{mycnt}
\setcounter{mycnt}{\value{enumi}}
\end{enumerate}
Once all ballots have been processed in this way, the certificate
determines winners and contains
winners by exhibiting
\begin{enumerate}
\setcounter{enumi}{4}
\item \label{it:pub-dm} the fully constructed margin, together with its decryption  
  and a ZKP of honest decryption after counting all the ballots     
\item publishes the winner(s), together with evidence to substantiate the
    claim
\end{enumerate}

\smallskip\noindent\emph{Cryptographic primitives.}
We require an additively homomorphic cryptosystem to
compute the (encrypted) margin matrix according to Equation
\ref{eqn:enc-mm} (this implements Item \ref{it:upd-marg} above). All
other primitives fall into one of three categories.
\emph{Verification primitives} are used to syntactically define
the type of valid certificates. For example, when publishing the
decrypted margin matrix in Item \ref{it:pub-dm} above, we require
that the zero knowledge proof in fact evidences correct decryption.
To
guarantee this, we need a verification primitive that -- given
ciphertext, plaintext and zero knowledge proof -- verifies whether the supplied proof
indeed evidences that the given ciphertext corresponds to the given
plaintext. In particular, verification primitives are always boolean
valued functions. While verification primitives \emph{define} valid
certificates, \emph{generation primitives} are used to
\emph{produce} valid certificates. In the example above, we need a
decryption primitive (to decrypt the homomorphically computed
margin) and a primitive to generate a zero knowledge proof (that
witnesses correct decryption). Clearly verification and generation
primitives have a close correlation, and we need to require, for
example, that zero knowledge proofs obtained via a generation
primitive has to pass muster using the corresponding verification
primitive. 

The three primitives described above (decryption, generation of a
zero knowledge proof, and verification of this proof) already allow
us  to implement the entire protocol with exception of ballot
shuffling (Item \ref{it:shuff} above).  Here, the situation is more
complex. While existing mixing schemes (e.g. \citep{Bayer:2012:EZK}) permute 
an array of ciphertexts and produce a zero knolwedge proof that
evidences the correctness of the shuffle, our requirement dictates
that every row and colum of the (matrix) ballot is
shuffled with the \emph{same} (secret) permutation.  In other words,
we need to retain the identity of the permutation to guarantee that
each row and column of a ballot have been shuffled by the same
permutation.
We achieve this by
committing to a permutation using Pedersen's commitment scheme
\citep{Pederson}.
In a nutshell, the Pedersen commitment scheme has the following properties. 
\begin{itemize}
\item Hiding: the commitment reveals no information about the
permutation
\item Binding: no party can open the commitment in more  
	 	than one way, i.e. the commitment is to one permutation only. 
\end{itemize}

\noindent
A combination of Pedersen's commitment scheme 
with a zero knowledge proof leads to a similar two step protocol, also known 
as commitment-consistent proof of shuffle \citep{Wikstrom:2009:CPS}.

\begin{itemize}
\item Commit to a secret permutation and publish the commitment (hiding).
\item Use a zero knowledge proof to show that shuffling has used 
      the same permutation which we committed to in previous step (binding).
\end{itemize}  

\noindent
This allows us to witness the validity (or otherwise) of a ballot by generating a 
permutation $\pi$ which is used to shuffle every row and column of the ballot.
We hide $\pi$ by committing it using Pedersen's 
commitment scheme 
and record the commitment $c_{\pi}$ in the certificate. However, for the binding step, rather 
than opening $\pi$ we generate a zero knowledge proof, $zkp_{\pi}$, 
using $\pi$ and $c_{\pi}$, which can 
be  used to prove that $c_{\pi}$ is indeed the commitment to some permutation
used in the (commitment consistent) shuffling 
 without being opened \citep{Wikstrom:2009:CPS}. We can now use the
 permutation that we have committed to for 
shuffling each row and column of a ballot, and evidence the
correctness of the shuffle via a zero knowledge proof.
%
To evidence validity (or otherwise) of a (single) ballot, we
therefore:
\begin{enumerate}
  \item generate a (secret) permutation and publish a commitment to this
  permutation, together with a zero knowledge proof that evidences commitment
  to a permutation
  \item for each row of the ballot, publish a shuffle of the row with
  the permutation committed to, together with a zero knowledge proof
  that witnesses shuffle correctness
  \item for each column of the row shuffled ballot, publish a
  shuffle of the column, also together with a zero knowledge proof of
  correctness 
  \item publish the decryption the ballot shuffled in this way, together with a
  zero knowledge proof that witnesses honest decryption
  \item decide the validity of the ballot based on the decrypted
  shuffle.
\end{enumerate}

\noindent
The cryptographic primitives needed to implement this again fall
into the same classes. To define validity of certificates, we need
verification primitives
\begin{itemize}
  \item to decide whether a zero knowledge proof evidences that a
  given commitment indeed commits to a permutation 
  \item to decide whether a zero knowledge proof evidences the
  correctness of a shuffle relative to a given permutation
  commitment.
\end{itemize}

\noindent
Dual to the above, to generate (valid) certificates, we need the
ability to
\begin{itemize}
  \item generate permutation commitments and accompanying zero
  knowledge proofs that evidence commitment to this permutation
  \item generate shuffles relative to a commitment, and zero
  knowledge proofs that evidence the correctness of shuffles.
\end{itemize}

\noindent
Again, both need to be coherent in the sense that the zero knowledge
proofs produced by the generation primitives need to pass
validation. In summary, we require an additively homomorphic
cryptosystem that implements the following:

\begin{description}
\item[Decryption Primitives.]
  decryption of a ciphertext, creation and verification of
 honest decryption zero knowledge proofs. 

\item[Commitment Primitives.]
  generating permutations, creation and verification of commitment
  zero knowledge proofs
\item[Shuffling Primitives.]
  commitment consistent shuffling, creation and verification of
  commitment consistent zero knowledge shuffle proofs 
\end{description}

\smallskip\noindent\emph{Witnessing of Winners.}
Once all ballots are counted, the computed margin is decrypted, and
winners (together with evidence of winning) are computed using 
plaintext counting. We discuss this part only briefly, for sake of completeness,
 as it is identical to the Section \ref{sec:evidence}.
 For each of the winners $w$ and each
candidate $x$ we publish
\begin{itemize}
\item a natural number $k(w, x)$ and a path $w = x_0, \dots, x_n = x$ of strength $k$
\item a set $C(w, x)$ of pairs of candidates that is $k$-coclosed
and contains $(x, w)$
\end{itemize}
where a set $S$ is  $k$-coclosed if for all $(x,z) \in C$ we have
that $m(x, z) < k$ and either $m(x, y) < k$ or $(y,z) \in S$ for
all candidates $y$.  Informally, the first requirement ensures that
there is no direct path (of length one) between a pair $(x, z) \in
S$, and the second requirement ensures that for an element $(x, z)
\in S$, there cannot be a path that connects $x$ to an intermediate
node $y$ and then (transitively) to $z$ that is of strength $\geq
k$.


\section{Formalization in Coq} \label{sec:realisation}



As we stated in the beginning of this chapter that the purpose of this work is
not to verify cryptographic primitives, 
but use them as a tool to construct evidence which can be used 
to audit and verify the outcome during different phase 
of election. Here, we treat them as abstract entities and assume
axioms about them inside Coq.
In particular, we assume the existence of functions that implement
each of the primitives described in the previous section, and
postulate natural axioms that describe how the different primitives
interact. As a by-product, we obtain an axiomatisation of a
cryptographic library that we could, in a later step, verify the
implementation of a cryptosystem against.  In particular, this
allows us to not commit to any particular cryptosystem in particular
(although our development, and later instantiation, is geared
towards El Gamal \citep{DBLP:conf/crypto/Gamal84}).

The first part of our formalisation concerns the cryptographic
primitives that we collect in a separate module. Below is an example
of the generation / verification primitives for decryption, together
with coherence axioms.

\begin{minted}{coq}
Variable decrypt_message: 
  Group -> Prikey -> ciphertext ->  plaintext.

Variable construct_zero_knowledge_decryption_proof:
  Group -> Prikey -> ciphertext -> DecZkp.

Axiom verify_zero_knowledge_decryption_proof:
  Group -> plaintext -> ciphertext -> DecZkp -> bool.

Axiom honest_decryption_from_zkp_proof: forall group c d zkp, 
 verify_zero_knowledge_decryption_proof group d c zkp = true 
 -> d = decrypt_message grp privatekey c.
 
Axiom verify_honest_decryption_zkp (group: Group):
  forall (pt : plaintext) (ct : ciphertext) (pk : Prikey),
  (pt = decrypt_message group pk ct) ->
  verify_zero_knowledge_decryption_proof group pt ct 
  (construct_zero_knowledge_decryption_proof group pk ct) 
  = true.
  

\end{minted}
  
\noindent
The different keywords \texttt{Variable} and \texttt{Axiom}
are used as a convenience for 
extraction. The keyword  \texttt{Variable} is used if we want it
to be lambda abstracted otherwise keyword \texttt{Axiom}. In
the above, the first two functions, \texttt{decrypt\_message} and
\texttt{construct\_zero} \texttt{\_knowledge} \texttt{\_decryption} \texttt{\_proof} are
\emph{generation} primitives, whereas the function 
\texttt{verify\_zero} \texttt{\_knowledge} \linebreak
\texttt{\_decryption} \texttt{\_proof} is a
\emph{verification} primitive. We have two coherence axioms. The
first says that if the verification of a zero knowledge proof of
honest decryption succeeds, then the ciphertext indeed decrypts to
the given plaintext. The second stipulates that generated zero
knowledge proofs indeed verify. 

For ballots, we assume a type \texttt{cand} of candidates, and
represent plaintext and encrypted ballots as two-argument functions
that take plaintext, and ciphertexts, as values. 
\begin{minted}{coq}
    Definition pballot := cand -> cand -> plaintext.
    Definition eballot := cand -> cand -> ciphertext.
\end{minted}


 We now turn to the representation of certificates, and indeed to the
  definition of what it means to (a) count encrypted votes correctly
  according to the Schulze Method, and (b) produce a verifiable
  certificate of this fact. At a high level, we split the counting
  (and accordingly the certificate) into \emph{states}. This gives
  rise to a (inductive dependent) type \texttt{ECount}, parameterised
  by the ballots being counted.

  \begin{minted}{coq}
  Inductive ECount (group : Group) (bs : list eballot) : 
    EState -> Type
  \end{minted}

  \noindent
  Given a list \texttt{bs} of ballots, \texttt{ECount bs} is a
  inductive dependent type. In this case, given a state of counting
  (i.e. an inhabitant \texttt{estate} of \texttt{EState}), the type level application
  \texttt{ECount bs estate} is the \emph{type of evidence that proves
  that \texttt{estate} is a state of counting that has been reached
  according to the method}.  The states itself are represented by
  the type \texttt{EState}
where
\begin{itemize}
 \item \texttt{epartial} represents a partial state of counting,
 consisting of the homomorphically computed margin so far, the list
 of uncounted ballots and the list of invalid ballots encountered so
 far
 \item \texttt{edecrypt} represents the final decrypted margin
 matrix, and 
 \item \texttt{ewinners} is the final determination of winners. 
\end{itemize}
This is readily translated to the following Coq code:
 
\begin{minted}{coq}
Inductive EState : Type :=
 | epartial : (list eballot * list eballot) ->
              (cand -> cand -> ciphertext) -> EState
 | edecrypt : (cand -> cand -> plaintext) -> EState
 | ewinners : (cand -> bool) -> EState.
\end{minted}


% \includegraphics[width=\textwidth]{inductive.png}


\noindent
The constructors of \texttt{EState} then allow us to move from one
state to the next, under appropriate conditions that guarantee
correctness of the count. The different states during the 
counting represented by $ECount$ is tagged by five constructors: 
\begin{itemize}
\item \texttt{ecax}: marks the beginning of counting
\item \texttt{ecvalid}: process a ballot from cast-ballots pile, and the ballot is a valid ballot
\item \texttt{ecinvalid}: process a ballot from cast-ballot pile, and the ballot is a invalid ballot
\item \texttt{ecdecrypt}: decryption of fully constructed homomorphic margin from the cast-ballot
\item \texttt{ecfin}: declaration of winner and loser based on the decrypted margin
\end{itemize}

Inductive type $ECount$ with all the constructors filled with \textit{state data}, 
\textit{verification data}, and \textit{correctness constraint}.  The first constructor, \texttt{ecax}, bootstraps
the count and ensures that 
\begin{itemize}
  \item all ballots are initially uncounted
  \item margin matrix is an encryption of the zero matrix
\end{itemize}

\begin{description}
  \item[state data:] here, the list of uncounted and invalid ballots,
  and the encrypted homomorphic margin
  \item[verification data:] a zero knowledge proof that the encrypted
  homomorphic margin is indeed an encryption of the zero margin
  \item[correctness constraints:] here, the constructor may only be applied if
  the list of uncounted ballots is equal to the list of ballots
  cast, and the fact that the zero knowledge proofs indeed verify
  that the initial margin matrix is identically zero.
\end{description}

\noindent
The main difference between the correctness condition, and the
verification data is that the former can be simply be inspected
(here by comparing lists) whereas the latter requires additional
data (here  in the form of a zero knowledge proof). In Coq, 
this constructor can be encoded as:

\begin{minted}{coq}
 Inductive ECount (grp : Group) (bs : list eballot) : 
  EState -> Type :=
  | ecax (us : list eballot) 
      (encm : cand -> cand -> ciphertext)
      (decm : cand -> cand -> plaintext)
      (zkpdec : cand -> cand -> DecZkp) :
      us = bs ->
      (forall c d : cand, decm c d = 0) -> 
      (forall c d, verify_zero_knowledge_decryption_proof 
          grp (decm c d) (encm c d) (zkpdec c d) = true) ->
    ECount grp bs (epartial (us, []) encm)
\end{minted}



The constructor \texttt{ecvalid} represents the effect of counting a
valid ballot. Here the crucial aspect is that validity needs to be
evidenced. As before, we have:
\begin{description}
  \item[state data:] as before, the list of uncounted and invalid
  ballots, the homomorphic margin, but additionally evidence that
  the previous state has been obtained correctly
  \item[verification data:]
  a commitment to a (secret) permutation, a row permutation of the
  ballot being counted, and a column permutation of this, and a
  decryption of the row- and column permuted ballot (all with
  accompanying zero knowledge proofs)
  \item[correctness constraints:] all the zero knowledge proofs
  verify, the new margin is the homomorphic addition of the previous
  margin and the counted ballot, and the decrypted (shuffled)
  ballot is indeed valid. 
\end{description}

\begin{minted}{coq}
  | ecvalid (u : eballot) (v : eballot) (w : eballot)
     (b : pballot) (zkppermuv : cand -> ShuffleZkp)
     (zkppermvw : cand -> ShuffleZkp) 
     (zkpdecw : cand -> cand -> DecZkp)
     (cpi : Commitment) (zkpcpi : PermZkp)
     (us : list eballot) 
     (m nm : cand -> cand -> ciphertext)
     (inbs : list eballot) :
     ECount grp bs (epartial (u :: us, inbs) m) ->
     (* valid ballot *)
     matrix_ballot_valid b ->
     (* commitment proof *)
     verify_permutation_commitment grp 
         (List.length cand_all) cpi zkpcpi = true ->
     (forall c, verify_row_permutation_ballot grp 
         u v cpi zkppermuv c = true)  ->
     (forall c, verify_col_permutation_ballot grp 
         v w cpi zkppermvw c = true)  ->
     (forall c d, verify_zero_knowledge_decryption_proof 
          grp (b c d) (w c d) (zkpdecw c d) = true)  ->
     (forall c d, nm c d = homomorphic_addition
          grp (u c d) (m c d)) -> 
     ECount grp bs (epartial (us, inbs) nm)
       \end{minted}
 
  

The constructor \texttt{ecinvalid}  is very similar to \texttt{ecvalid}.  
We elide the description of the constructor that is applied
when an invalid ballot is being encountered (the only
difference is that the margin matrix is not being updated and ballot is moved to 
list of invalid ballots). 

\begin{minted}{coq}
  | ecinvalid (u : eballot) (v : eballot) (w : eballot)
     (b : pballot) (zkppermuv : cand -> ShuffleZkp)
     (zkppermvw : cand -> ShuffleZkp)
     (zkpdecw : cand -> cand -> DecZkp)
     (cpi : Commitment) (zkpcpi : PermZkp)
     (us : list eballot) (m : cand -> cand -> ciphertext)
     (inbs : list eballot) :
     ECount grp bs (epartial (u :: us, inbs) m) ->
     (* invalid ballot *)
     ~matrix_ballot_valid b ->
     (* commitment proof *)
     verify_permutation_commitment grp
        (List.length cand_all) cpi zkpcpi = true ->
     (forall c, verify_row_permutation_ballot grp
        u v cpi zkppermuv c = true) ->
     (forall c, verify_col_permutation_ballot grp
        v w cpi zkppermvw c = true) ->
     (forall c d, verify_zero_knowledge_decryption_proof 
        grp (b c d) (w c d) (zkpdecw c d) = true) ->
     ECount grp bs (epartial (us, (u :: inbs)) m)
\end{minted}

 

Counting finishes when there are no more uncounted ballots and this state is 
marked by constructor $ecdecrypt$, in
which case the next step is to publish the decrypted margin matrix.
Also here, we have
\begin{description}
  \item[state data:] the decrypted margin matrix, plus evidence
  that a state with no more uncounted ballots has been obtained
  correctly
  \item[verification data:] a zero knowledge proof that demonstrates
  honest decryption of the final margin matrix
  \item[correctness constraints:] the given zero knowledge proof
  verifies, i.e. the given decrypted margin is indeed the decryption
  of the (last) homomorphically computed margin matrix.
\end{description} 

 \begin{minted}{coq}
  | ecdecrypt inbs 
      (encm : cand -> cand -> ciphertext)
      (decm : cand -> cand -> plaintext)
      (zkp : cand -> cand -> DecZkp) :
      ECount grp bs (epartial ([], inbs) encm) ->
      (forall c d, verify_zero_knowledge_decryption_proof
          grp (decm c d) (encm c d) (zkp c d) = true) ->
      ECount grp bs (edecrypt decm)
 \end{minted}
 
 
 
 \noindent
The last constructor, $ecfin$, finally declares the winners of the election,
and we have:
\begin{description}
  \item[state data:] a function \texttt{cand -> bool} that determines
  winners, plus evidence of the fact that the decrypted final margin
  matrix has been obtained correctly
  \item[verification data:] 
   paths and co-closed sets that evidence the correctness of the
   function above
 \item[correctness constraints:] that ensure that the verification
 data verifies the winners given by the state data.
\end{description}
This last part is same as the previous chapter's 
scrutiny sheet (section \ref{sec:scrunity_sheet}).

 \begin{minted}{coq}
  | ecfin dm w 
      (d : (forall c, (wins_type dm c) + 
                      (loses_type dm c))) :
      ECount grp bs (edecrypt dm) ->
      (forall c, w c = true <-> (exists x, d c = inl x)) ->
      (forall c, w c = false <-> (exists x, d c = inr x)) ->
      ECount grp bs (ewinners w).  

\end{minted}













\section{Correctness by Construction and Verification}
\label{sec:correct}

In the previous section, we have presented a data type that
\emph{defines} the notion of a verifiably correct count of the
Schulze Method, on the basis of encrypted ballots. To obtain an
executable that in fact \emph{produces} a verifiable (and provably
correct) count, we can proceed in either of two ways:
\begin{enumerate}
  \item implement a function that -- give a list \texttt{bs} of
  ballots -- produces a boolean function \texttt{w} (for winners) and an
  element of the type \texttt{ECount bs (winners w)}. This gives
  both the election winners (\texttt{w}) as well as evidence (the
  element of the \texttt{ECount} data type).
  \item to prove that for every set \texttt{bs} of encrypted
  ballots, we have a boolean function \texttt{w} and an inhabitant
  of the type \texttt{ECount bs (winners w)}.
\end{enumerate}

\noindent
Under the proofs-as-programs interpretation of constructive type
theory, both amount to the same. We chose the latter approach, and
our main theorem formally states that all elections can be
counted according to the Schulze Method (with encrypted ballots),
i.e. a winner can always be found. Formally, our main theorem takes
the following form:
\begin{minted}{coq}
Lemma encryption_schulze_winners (group : Group) 
 (bs : list eballot) : existsT (f : cand -> bool), 
 ECount group bs (ewinners f).
\end{minted}

\noindent
The proof proceeds by successively building an inhabitant of
\texttt{EState} by homomorphically computing the margin matrix, then
decrypting and determining the winners. Within the proof, we use
both generation primitives (e.g. to construct zero knowledge proofs)
and coherence axioms (to ensure that the zero knowledge proofs
indeed verify). 

The correctness of our entire approach stands or falls with the
correct formalisation of the inductive data type \texttt{ECount}
that is used to determine the winners of an election counted
according to the Schulze Method. While one can argue that the data
type itself is transparent enough to be its own specification,
the cryptographic aspect makes things slightly more complex. For
example, it appears to be credible that our mechanism for
determining validity of a ballot is correct -- however we have not
given proof of this. Rather than scrutinising the details of the
construction of this data type, we follow a different approach: we
demonstrate that homomorphic counting always yields the same results
as plaintext counting, where plaintext counting is already verified
against its specification (Chapter \ref{cha:schulze_method}). 
This correspondence has two directions, and both assume that we are given
two lists of ballots that are the encryption (resp. decryption) of
one another. 


The first theorem, \texttt{plaintext\_} \texttt{schulze\_to} \texttt{\_homomorphic}, 
reproduced below shows
that every winner that can be determined using plaintext counting
can also be evidenced on the basis of corresponding encrypted ballots. The
converse of this is established by 
Theorem \texttt{homomorphic} \texttt{\_schulze} \texttt{\_to\_plaintext}.

\begin{minted}{coq}
Lemma plaintext_schulze_to_homomorphic 
 (group : Group) (bs : list ballot): 
 forall (pbs : list pballot) (ebs : list eballot) 
 (w : cand -> bool), (pbs = map (fun x => (fun c d => 
 decrypt_message group privatekey (x c d))) ebs) ->
 (mapping_ballot_pballot bs pbs) -> 
 Count bs (winners w) -> ECount group ebs (ewinners w).
      
Lemma homomorphic_schulze_to_plaintext 
 (group : Group) (bs : list ballot):
 forall (pbs : list pballot) (ebs : list eballot) 
 (w : cand -> bool) (pbs = map (fun x => (fun c d => 
 decrypt_message group privatekey (x c d))) ebs) ->
 (mapping_ballot_pballot bs pbs) ->
 ECount grp ebs (ewinners w) -> Count bs (winners w).
\end{minted}

\noindent
The theorems above feature a third type of ballot that is the basis
of plaintext counting, and is a simple ranking function of type
\texttt{cand -> Nat}, and the two hypotheses on the three types of
ballots ensure that the encrypted ballots (\texttt{ebs}) are in fact
in alignment with the rank-ordered ballots (\texttt{bs}) that are
used in plaintext counting. The proof, and indeed the formulation, 
relies on an inductive data
type \texttt{Count}  (Section \ref{sec:inductive_type}) that can best be 
thought of as a plaintext
version of the inductive type  \texttt{ECount} given here.
Crucially, \texttt{Count} is verified against a formal specification
of the Schulze Method. Both theorems are proven by induction on the
definition of the respective data types, where the key step is to
show that the (decrypted) final margins agree. The key ingredient
here are the coherence axioms that stipulate that zero knowledge
proofs that verify indeed evidence shuffle and/or honest decryption.


\section{Extraction and Experiments} \label{sec:extract}

As discussed in the Section \ref{sec:typeprop}, 
we are using  the Coq extraction
mechanism\citep{Letouzey:2003:NEC}  to extract programs from
existence proofs\footnote{https://github.com/mukeshtiwari/EncryptionSchulze/tree/master/code/Workingcode}.
In particular, we extract the proof of the Theorem
\texttt{pschulze\_winners}, given in Section \ref{sec:correct} to a
program that delivers not only provably correct counts, but also
verifiable evidence.  Give a set of encrypted ballots and a \texttt{Group}
that forms the basis of cryptographic operations, we obtain a program that
delivers not only a set of winners, but additionally independently  verifiable
evidence of the correctness of the count. 

Indeed, the entire formulation of our data type, and the split into
state data, verification data, and correctness constraints, has been
geared towards extraction as a goal. Technically, the verification
conditions are \emph{propositions}, i.e. inhabitants of Type
\emph{Prop} in the terminology of Coq, and hence erased at
extraction time. This corresponds to the fact that the assertions
embodied in the correctness constraints can be verified with minimal
computational overhead, given the state and the verification data.
For example, it can simply be verified whether or not a zero
knowledge proof indeed verifies honest decryption by running
it through a verifier.  On the other hand, the zero knowledge proof
itself (which is part of the verification data) is crucially needed
to be able to verify that a plaintext is the honest decryption of a
ciphertext, and hence cannot be erased during extraction.
Technically, this is realised by formulating both state and
verification data at type level (rather than as propositions). 

As we have explained in Section \ref{sec:realisation}, the formal
development does not pre-suppose any specific implementation of the
cryptographic primitives, and we assume the existence of
cryptographic infrastructure. From the perspective of extraction,
this produces an executable with ``holes'', i.e. the cryptographic
primitives need to be supplied to fill the holes and indeed be able
to compile and execute the extracted program.  

To fill this hole, we implement the cryptoraphic primitives with
help of the UniCrypt library\citep{LocherH14}.
UniCrypt is a freely available library, written in Java,  that provides nearly all of
the required functionality, with the exception of honest decryption
zero knowledge proofs.  We extract our proof development into OCaml
and use Java/OCaml bindings~\citep{OCamlJava} to make the UniCrypt
functionality available to our OCaml program. Due to differences
in the type structure between Java and OCaml, mainly in the context
of sub-typing, this was done in the form of an OCaml wrapper around
Java data structures.  After instantiating the  
 cryptographic primitives in the extracted OCaml code with wrapper
 code that calls UniCrypt,
 we tested the executable on a three candidate elections between
 candidates \texttt{A}, \texttt{B} and \texttt{C}.
 The computation produces a tally sheet that is schematically given
 below:
 it is trace of computation which can be used as a checkable record to verify
 the outcome of election. We elide the cryptographic detail, e.g.
 the concrete representation of zero knowledge proofs.
 A certificate
 is be obtained from the type \texttt{ECount} where the head
 of the certificate corresponds to the base case of the inductive
 type, here \texttt{ecax}. Below, \texttt{M} is encrypted margin
 matrix, \texttt{D} is its decrypted equivalent, required to be
 identically zero, and \texttt{Z} represents a matrix of zero
 knwoledge proofs, each establishing that the \texttt{XY}-component
 of \texttt{M} is in fact an encryption of zero. All these matrices
 are indexed by candidates and we display these matrices by listing
 their entries prefixed by a pair of candidates, e.g. the ellipsis
 in \texttt{AB(...)} denotes the matrix entry at row \texttt{A} and
 column \texttt{B}.

 {\small
 \begin{verbatim}
 M: AB(rel-marg-of-A-over-B-enc), AC(rel-marg-of-A-over-C-enc), ... 
 D: AB(0)                       , AC(0)                       , ...
 Z: AB(zkp-for-rel-marg-A-B)    , AC(zkp-for-rel-marg-A-C)    , ...
 \end{verbatim}}
 
 \mbox{}\\[-5ex]
 Note that one can verify the fact that the initial encrypted margin
 is in fact the zero margin by just verifying the zero knowledge
 proofs. Successive entries in the certificate will generally be
 obtained by counting valid, and discarding invalid ballots. If a
 valid ballot is counted after the counting commences, the
 certificate would continue by exhibiting the state and verification
 data contained in the \texttt{ecvalid} constructor which can be
 displayed schematically as follows:

 {\small\begin{verbatim}
 V: AB(ballot-entry-A-B) , AC(ballot-entry-A-C), ...
 C: permutation-commitment
 P: zkp-of-valid-permutation-commitment
 R: AB(row-perm-A-B)     , AC(row-perm-A-C)    , ...
 RP: A(zkp-of-perm-row-A), B(zkp-of-perm-row-B), ... 
 C: AB(col-perm-A-B),      AC(col-perm-A-C)    , ...
 CP: A(zkp-of-perm-col-A), B(zkp-of-perm-col-B), ...
 D: AB(dec-perm-bal-A-B) , AC(dec-perm-bal-A-C), ...
 Z: AB(zkp-for-dec-A-B)  , AC(zkp-for-dec-A-C) , ...
 M: AB(new-marg-A-B)     , AC(new-marg-A-C)    , ...
 \end{verbatim}}

 \mbox{}\\[-5ex]
 Here \texttt{V} is the list of ballots to be counted, where we only
 diplay the first element. We
 commit to a permutation and validate this commitment with a zero
 knowledge proof, here given in the second and third line, prefixed
 with \texttt{C} and \texttt{P}. The following two lines are a row
 permutation of the ballot \texttt{V}, together with a zero
 knowledge proof of correctness of shuffling (of each row) with
 respect to the permutation committed to by \texttt{C} above. The
 following two lines achieve the same for subsequently permuting the
 columns of the (row permuted) ballot. Finally, \texttt{D} is the
 decrypted permuted ballot, and \texttt{Z} a zero knowledge proof of
 honest decryption. We end with an updated homomorphic margin
 matrix \texttt{M}. Again, we note that the validity of the
 decrypted ballot can be checked easily, and validating zero
 knowledge proofs substantiate that the decrypted ballot is indeed a
 shuffle of the original one. Homomorphic addition can simply be
 re-computed.

 The steps where invalid ballots are being detected is similar, with
 the exception of not updating the margin matrix. Once all ballots
 are counted, the only applicable constructor is \texttt{ecdecrypt},
 the data content of which would continue a certificate
 schematically as follows:

 {\small\begin{verbatim}
 V: []
 M: AB(fin-marg-A-B), AC(fin-marg-A-C), ...
 D: AB(dec-marg-A-B), AC(dec-marg-A-C), ...
 Z: AB(zkp-dec-A-B) , AC(zkp-dec-A-C) , ...
 \end{verbatim}}

 \mbox{}\\[-5ex]
 Here the first line indicates that there are no more ballots to be
 counted, \texttt{M} is the final encrypted margin matrix,
 \texttt{D} is its decryption and \texttt{Z} is a matrix of zero
 knowledge proofs verifying the correctness of decryption.

 The certificate would end with the determination of winners based
 on the encrypted margin, and would end with the content of the
 \texttt{ecfin} constructor

 {\small\begin{verbatim}
 winning: A, <evidence that A wins against B and C>
 losing:  B, <evidence that B loses against A and C>
 losing:  C, <evidence that C loses against A and B>
 \end{verbatim}}

 \mbox{}\\[-5ex]
 where the notion of evidence for winning and losing is as in the
 plaintext version of the protocol (Chapter \ref{cha:schulze_method}).  
 
 \noindent
 \textit{Concrete Certificate:} Below is a glimpse of a concrete certificate for an election. 
We have stripped off 
the trailing digits in the tally sheet which is marked by $..$, and rather 
 than representing an entry of a matrix as ($i$, $j$), it is represented as 
 $ij$

\begin{lstlisting}[frame=none, numbers=none, basicstyle=\ttfamily\scriptsize]

M: AA(13.., 10..) AB(90.., 14..)  AC(11.., 23..) BA(16.., 13..) 
BB(79.., 46..) BC(12.., 14..) CA(50.., 53..) CB(70.., 68..) CC(23.., 82..), 
D: [AA: 0 AB: 0 AC: 0 BA: 0 BB: 0 BC: 0 CA: 0 CB: 0 CC: 0], 
Zero-Knowledge-Proof-of-Honest-Decryption: [..]
------------------------------------------------------------------------------
V: [AA(42.., 15..) AB(63.., 32..) AC(70, 44..) BA(47.., 34..) BB(16.., 28..)
BC(39.., 16..) CA(19.., 13..) CB(57.., 12..) CC(19.., 89..),..], I:  [], 
M: AA(12.., 11..) AB(13.., 66..) AC(16.., 14.) BA(48.., 31..) BB(15.., 52..)
BC(15.., 68..) CA(39.., 69..) CB(12.., 78..) CC(10.., 40..),
Row-Permuted-Ballot: AA(53.., 16..) AB(23.., 44..) AC(72.., 47..) 
BA(10.., 19..) BB(74.., 16..) BC(20.., 60..) CA(44.., 10..) CB(12.., 16..)
CC(59.., 98..),
Column-Permuted-Ballot: AA(81.., 41..) AB(17.., 14..) AC(10.., 14..) 
BA(37.., 12..) BB(14.., 66..) BC(10.., 13..) CA(12.., 13..) CB(14.., 16..)
CC(12.., 10..),
Decryption-of-Permuted Ballot: AA0 AB-1 AC1 BA1 BB0 BC1 CA-1 CB-1 CC0,
Zero-Knowledge-Proof-of-Row-Permutation: [Tuple[...]], 
Zero-Knowledge-Proof-of-Column-Permutation: [Tuple[..]], 
Zero-Knowledge-Proof-of-Decryption: [Triple[..]], 
Permutation-Commitment: Triple[..]
Zero-Knowledge-Proof-of-Commitment: Tuple[..]
------------------------------------------------------------------------------
.
.
.
------------------------------------------------------------------------------
V: [AA(36.., 10..) AB(20.., 13..) AC(75.., 43..) BA(13.., 31..) BB(27.., 82..)
BC(31.., 50..) CA(16.., 11..) CB(74.., 15..) CC(26.., 36..)], I: [],
M: AA(86.., 38..) AB(21.., 14..) AC(16.., 25..) BA(16.., 22..) BB(18.., 15..)
BC(11.., 63..) CA(15.., 34..) CB(76.., 18..) CC(11.., 10..), 
Row-Permuted-Ballot: .., Column-Permuted-Ballot: .., 
Decryption-of-Permuted-Ballot: AA0 AB-10 AC1 BA10 BB0 BC1 CA-1 CB-1 CC0,
Zero-Knowledge-Proof-of-Row-Permutation: [..],
Zero-Knowledge-Proof-of-Column-Permutation: [..], 
Zero-Knowledge-Proof-of-Decryption: [..], 
Permutation-Commitment: Triple[..], 
Zero-Knowledge-Proof-of-Commitment: Tuple[..]
------------------------------------------------------------------------------
V: [], I: [AA(36.., 10..) AB(20.., 13..) AC(75.., 43..) BA(13.., 31..) 
BB(27.., 82..) BC(31.., 50..) CA(16.., 11..) CB(74.., 15..) CC(26.., 36..)], 
M: .., D: [AA: 0 AB: 4 AC: 4 BA: -4 BB: 0 BC: 4 CA: -4 CB: -4 CC: 0],
Zero-Knowledge-Proof-of-Decryption: [..]
------------------------------------------------------------------------------
D: [AA: 0 AB: 4 AC: 4 BA: -4 BB: 0 BC: 4 CA: -4 CB: -4 CC: 0]
winning: A
   for B: path A --> B of strength 4, 5-coclosed set: 
       [(B,A),(C,A),(C,B)]
   for C: path A --> C of strength 4, 5-coclosed set:
       [(B,A),(C,A),(C,B)] 
losing: B
   exists A: path A --> B of strength 4, 4-coclosed set: 
     [(A,A),(B,A),(B,B),(C,A),(C,B),(C,C)]
losing: C
   exists A: path A --> C of strength 4, 4-coclosed set: 
     [(A,A),(B,A),(B,B),(C,A),(C,B),(C,C)]

\end{lstlisting}


\begin{figure}
\centering
%\vspace*{-1cm}
\includegraphics[scale=0.80]{PlotVer3.png}
\caption{Experimental Result}
  \label{fig:experimental_result}
\end{figure}
 We note that the schematic presentation of the certificate above is
 nothing but a representation of the data contained in the extracted
 type \texttt{ECount} that we have chosen to present schematically.
 Concrete certificates can be inspected with the accompanying proof
 development, and are obtained by simply implementing datatype to
 string conversion on the type \texttt{ECount}.
 



To demonstrate proof of concept, 
we have run our experiment on an  Intel  i7  2.6  GHz  Linux  desktop  computer
with  16GB  of  RAM for three candidates and randomly generated ballots (Figure \ref{fig:experimental_result}). 
The largest  amount of ballot we counted was 10,000 (not included in
graph), with a runtime of 25 hours. A more detailed analysis reveals
that the bottleneck are the bindings between OCaml and Java. More
specifically, producing the cryptographic evidence using the
UniCrypt Library for 10,000 ballots takes about 10 minutes, and the
subsequent computation (which is the same as for the plaintext
count) takes negligible time. This is consistent with the mechanism
employed by the bindings:
each function call from OCaml to Java is inherently memory bounded
and creates an instance of the Java runtime, 
the conversion of OCaml data structures into Java data
structures, 
computation by respective Java function producing result,
converting the result back into OCaml data structure, and finally destroying 
the Java runtime instance when the function returns. While the proof
of concept using OCaml/Java bindings falls short of being
practically feasible, our timing analysis substantiates that
feasibility can be achieved by eliminating the overhead of the
bindings. 


\section{Summary}
\label{sec:summary_homomorphic}

\noindent The main contribution of our formalisation is that of independently
verifiable \emph{evidence} for a set of candidates to be the winners
of an election counted according to the Schulze method. Our main
claim is that our notion of evidence is both safeguarding the
privacy of the individual ballot (as the count is based on encrypted
ballots) and is verifiable at the same time (by means of zero
knowledge proofs). To do this, we have axiomatised a set of
cryptographic primitives to deal with encryption, decryption,
correctness of shuffles and correctness of decryption. From formal
and constructive proof of the fact that such evidence can always be
obtained, we have then extracted executable code that is provably
correct by construction and produces election winners together with
evidence once implementations for the cryptographic primitives are
supplied.

In a second step, we have supplied an implementation of these
primitives, largely based on the UniCrypt Library. Our experiments
have demonstrated that this approach is feasible, but quite clearly
much work is still needed to improve efficiency. 

\smallskip\noindent\emph{Assumptions for Provable Correctness.}
While we claim that the end product embodies a high level of
reliability, our approach necessarily leaves some gaps between the
executable and the formal proofs. First and foremost, this is of
course the implementation of the cryptographic primitives in an
external (and unverified) library. We have minimised this gap by
basing our implementation on a purpose-specific existing library
(UniCrypt) to which we relegate most of the functionality. 


\smallskip\noindent\emph{Modelling Assumptions.} In our modelling of
the cryptographic primitives, in particular the zero knowledge
proofs, we assumed properties which in reality only hold with
very high probability. As a
consequence our correctness assertions only hold to the level
of probability that is guaranteed by zero knowledge proofs (sigma 
protocols).

\smallskip\noindent\emph{Scalability.} We have analysed the
feasibility of the extracted code by counting an increasing number
of ballots. While this demonstrates a proof of concept, our results
show that the bindings used to couple the cryptographic layer with
our code adds significant overhead compared
to plaintext tallying (\ref{cha:schulze_method}). Given that both
parts are practically efficient by themselves, scalability is merely
the question of engineering a more efficient coupling. 


In a nutshell, the achieved and failed part of this formalization:

\begin{itemize}
\item Achieved
\begin{itemize}
\item Correctness: The implementation is formalized in Coq assuming the 
         existence of cryptographic 
         functions and axioms about their correctness behaviour. These primitives were 
         used for constructing evidence, or certificate. 
         
\item Privacy : We don't reveal the content of ballot at any phase of election counting. Therefore, 
         there is no possibility of anyone knowing the choices of a voter other than the voter herself.
                 
\item Verifiability: The outcome of any election can be verified by any third party because 
          of the generated certificates. However,
          the nature of certificates in this case is very complex, and they can only be scrutinize 
          by someone having specialized knowledge of cryptography which decreases the pool of potential 
          scrutinizers dramatically.

\end{itemize}
\item Failed
\begin{itemize}
 \item Correctness: We use an external unverified library for cryptographic code.  In general, this library 
 		  could have bugs and 
          may produce a wrong result. This is not a problem per say because it will be caught during the 
          certificate checking by any independent party, but it may create a atmosphere of distrust among 
          voters.  
 
 
\end{itemize}
\end{itemize}


\noindent
Our formalization leaves some gaps which needed to be filled:
\begin{itemize}
\item A formally verified cryptographic library to fill the \textit{correctness gap}.
\item A formally verified checker to ease the auditing of election to fill the \textit{scrutineers} gap
\end{itemize}


Developing a formally verified library to fill the correctness gap would have taken more time,
specifically the commitment consistent shuffle, 
so we chose to formally verify the certificate checker to ease the auditing of election to 
increase the number of scrutineers gap. 
 
In the next chapter, we will focus on all the details needed to 
develop formally verified certificate checker for the certificate we produced in this chapter. 
However, we did not 
formalize every cryptographic primitive needed to verify our certificate. Rather, 
we have developed a proof of concept formally verified certificate checker for 
 International Association for Cryptologic Research 2018 election, a simpler 
 scrutiny sheet than ours which does not involve any shuffle. 
